[
  {
    "question": "how was the weather yesterday?",
    "answers": [
      {
        "text": "nice",
        "correct": true
      },
      {
        "text": "average",
        "correct": false
      },
      {
        "text": "not nice",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following facilities or abilities are required to provide mutual exclusion support?",
    "answers": [
      {
        "text": "the task stays in its critical section only for a finite amount of time",
        "correct": true
      },
      {
        "text": "task scheduling must be considered",
        "correct": false
      },
      {
        "text": "the relative speeds of the tasks must be taken into account",
        "correct": false
      },
      {
        "text": "a task that is performed outside the critical section must not affect the behavior of a task in the critical section",
        "correct": true
      }
    ]
  },
  {
    "question": "threads in operating system:",
    "answers": [
      {
        "text": "they share context except registers and stack",
        "correct": true
      },
      {
        "text": "they share the entire context",
        "correct": false
      },
      {
        "text": "they share context except stack",
        "correct": false
      }
    ]
  },
  {
    "question": "what is included in the context that must be saved for a synchronous (inter-instruction) precision interrupt?",
    "answers": [
      {
        "text": "instruction register",
        "correct": false
      },
      {
        "text": "collective of individual interrupt mask",
        "correct": true
      },
      {
        "text": "general purpose registers",
        "correct": true
      },
      {
        "text": "program counter",
        "correct": true
      }
    ]
  },
  {
    "question": "interrupt mask:",
    "answers": [
      {
        "text": "can unblock interrupts when the interrupt handler completes",
        "correct": true
      },
      {
        "text": "can be set and reset by special processor instructions",
        "correct": true
      },
      {
        "text": "causes interrupts to be disabled when an interrupt is accepted",
        "correct": true
      },
      {
        "text": "must be part of the status register",
        "correct": false
      }
    ]
  },
  {
    "question": "the direct resume rule means that:",
    "answers": [
      {
        "text": "the resuming process gets a critical region after the resumed process exits the critical region",
        "correct": false
      },
      {
        "text": "the resuming process applies for the critical region just like other processes waiting to enter the critical region",
        "correct": true
      },
      {
        "text": "the resuming process loses the critical region",
        "correct": true
      }
    ]
  },
  {
    "question": "general semaphore:",
    "answers": [
      {
        "text": "requires busy waiting",
        "correct": false
      },
      {
        "text": "is to perform only indivisible operations",
        "correct": true
      },
      {
        "text": "is a shared variable",
        "correct": true
      },
      {
        "text": "can be only non-negative",
        "correct": true
      }
    ]
  },
  {
    "question": "the system stack must provide space for:",
    "answers": [
      {
        "text": "processor registers in as many copies as there are interrupt lines and possible software interrupts",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are devices in the system +1",
        "correct": false
      },
      {
        "text": "cpu registers",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines +1",
        "correct": true
      }
    ]
  },
  {
    "question": "in a concurrent environment, the operating system decides which task the cpu gets, when, and for how long. this feature is called:",
    "answers": [
      {
        "text": "task scheduling",
        "correct": true
      },
      {
        "text": "traffic management",
        "correct": false
      },
      {
        "text": "task timetable planning",
        "correct": false
      },
      {
        "text": "task management",
        "correct": false
      }
    ]
  },
  {
    "question": "which scheduler needs to make a decision the fastest?",
    "answers": [
      {
        "text": "long-term",
        "correct": false
      },
      {
        "text": "short-term",
        "correct": true
      },
      {
        "text": "additional",
        "correct": false
      },
      {
        "text": "medium-term",
        "correct": false
      }
    ]
  },
  {
    "question": "using test-and-set or compare-and-swap in synchronization:",
    "answers": [
      {
        "text": "stops the processor if 0 is read",
        "correct": false
      },
      {
        "text": "it requires processes to actively wait",
        "correct": true
      },
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "it can only be applied in systems with shared memory",
        "correct": true
      }
    ]
  },
  {
    "question": "the environment in which the process is executed includes:",
    "answers": [
      {
        "text": "a set of environment variables",
        "correct": true
      },
      {
        "text": "contents of the interrupt request register",
        "correct": false
      },
      {
        "text": "the content in the memory management unit",
        "correct": false
      },
      {
        "text": "process address space",
        "correct": true
      }
    ]
  },
  {
    "question": "what is a scheduler?",
    "answers": [
      {
        "text": "procedure that schedules frame release in the page replace algorithm",
        "correct": false
      },
      {
        "text": "a kernel routine that selects a task to execute",
        "correct": true
      },
      {
        "text": "the system process that allocates the processor",
        "correct": false
      },
      {
        "text": "memory allocation procedure",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt request register is:",
    "answers": [
      {
        "text": "a register where interrupt line states are stored",
        "correct": true
      },
      {
        "text": "a register that blocks or unblocks individual interrupts",
        "correct": false
      },
      {
        "text": "a combinational circuit that calculates the number of the interrupt received",
        "correct": false
      },
      {
        "text": "a register that blocks or unblocks all interrupts",
        "correct": false
      }
    ]
  },
  {
    "question": "what does the kernel do when there is no task (process) to run?",
    "answers": [
      {
        "text": "starts the idle task",
        "correct": true
      },
      {
        "text": "executes an infinite loop in the kernel until a task arrives",
        "correct": false
      },
      {
        "text": "resets the entire system",
        "correct": false
      },
      {
        "text": "switches off the power supply",
        "correct": false
      }
    ]
  },
  {
    "question": "the scheduler decisions take the form:",
    "answers": [
      {
        "text": "change from active to ready state",
        "correct": false
      },
      {
        "text": "change from waiting to ready state",
        "correct": false
      },
      {
        "text": "change from ready to active state",
        "correct": true
      },
      {
        "text": "change from ready to waiting state",
        "correct": false
      }
    ]
  },
  {
    "question": "what are the functions of the kernel?",
    "answers": [
      {
        "text": "memory management",
        "correct": false
      },
      {
        "text": "program management",
        "correct": false
      },
      {
        "text": "interrupt handling",
        "correct": true
      },
      {
        "text": "file management",
        "correct": false
      }
    ]
  },
  {
    "question": "precise interrupts are:",
    "answers": [
      {
        "text": "unblocked only in a stable state between the execution of successive instructions",
        "correct": false
      },
      {
        "text": "accepted only in a stable state between the execution of successive instructions",
        "correct": true
      },
      {
        "text": "transferred only in a stable state between the execution of successive instructions",
        "correct": false
      },
      {
        "text": "only issued in a stable state between executions of subsequent instructions",
        "correct": false
      }
    ]
  },
  {
    "question": "processor access scheduling decisions may be made under which of the following circumstances?",
    "answers": [
      {
        "text": "when a task goes from the waiting state to the ready state",
        "correct": true
      },
      {
        "text": "when a task terminates",
        "correct": true
      },
      {
        "text": "when a task transitions from the active state to the ready state",
        "correct": true
      },
      {
        "text": "when a task goes from the active state to the waiting state",
        "correct": true
      }
    ]
  },
  {
    "question": "context switch is:",
    "answers": [
      {
        "text": "switching to the system stack",
        "correct": false
      },
      {
        "text": "calling the kernel of the operating system",
        "correct": false
      },
      {
        "text": "writing registers to the task stack and retrieving them from another task stack",
        "correct": true
      },
      {
        "text": "extracode execution",
        "correct": false
      }
    ]
  },
  {
    "question": "in a multitasking environment, the operating system decides which task the cpu gets, when, and for how long. this feature is called:",
    "answers": [
      {
        "text": "task timetable management",
        "correct": false
      },
      {
        "text": "task management",
        "correct": false
      },
      {
        "text": "task scheduling",
        "correct": true
      },
      {
        "text": "traffic control",
        "correct": false
      }
    ]
  },
  {
    "question": "in operating system:",
    "answers": [
      {
        "text": "some exceptions are handled, some not",
        "correct": false
      },
      {
        "text": "the decision to handle an exception or not is made dynamically",
        "correct": false
      },
      {
        "text": "every exception must be handled",
        "correct": true
      },
      {
        "text": "timer interrupt may not be handled",
        "correct": false
      }
    ]
  },
  {
    "question": "the number of tasks performed on the system in a given time is:",
    "answers": [
      {
        "text": "utilization",
        "correct": false
      },
      {
        "text": "throughput",
        "correct": true
      },
      {
        "text": "efficiency",
        "correct": false
      },
      {
        "text": "response time",
        "correct": false
      }
    ]
  },
  {
    "question": "when a suspended program is moved to auxiliary memory, its process state is called:",
    "answers": [
      {
        "text": "swept away",
        "correct": true
      },
      {
        "text": "exchanged",
        "correct": false
      },
      {
        "text": "moved out",
        "correct": false
      },
      {
        "text": "rinsed out",
        "correct": false
      }
    ]
  },
  {
    "question": "indulgent scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "system with many process classes",
        "correct": false
      },
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": true
      },
      {
        "text": "time-sharing system",
        "correct": false
      }
    ]
  },
  {
    "question": "what can happen when a job leaves the critical section and more than 1 task is waiting for the critical section?",
    "answers": [
      {
        "text": "deadlock waiting for critical section",
        "correct": false
      },
      {
        "text": "active waiting for a critical section",
        "correct": false
      },
      {
        "text": "starvation awaiting a critical section",
        "correct": true
      },
      {
        "text": "letting both tasks into the critical section",
        "correct": false
      }
    ]
  },
  {
    "question": "in the case of hardware interrupt summation ('wire or'):",
    "answers": [
      {
        "text": "the processor can programatically poll devices about issuing an interrupt",
        "correct": true
      },
      {
        "text": "the interrupt circuit can query devices about issuing an interrupt",
        "correct": false
      },
      {
        "text": "the bus driver can poll devices about issuing an interrupt",
        "correct": true
      },
      {
        "text": "the interrupt source is identified by a special bus signal",
        "correct": false
      }
    ]
  },
  {
    "question": "using test-and-set or compare-and-swap in synchronization:",
    "answers": [
      {
        "text": "stops the processor if 0 is read",
        "correct": false
      },
      {
        "text": "can be applied only in distributed systems",
        "correct": false
      },
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "it requires processes to actively wait",
        "correct": true
      }
    ]
  },
  {
    "question": "in a multitasking environment, the operating system decides which task the cpu gets, when, and for how long. this feature is called:",
    "answers": [
      {
        "text": "task timetable management",
        "correct": false
      },
      {
        "text": "traffic control",
        "correct": false
      },
      {
        "text": "task scheduling",
        "correct": true
      },
      {
        "text": "task management",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt vector is saved in a case of:",
    "answers": [
      {
        "text": "subroutine call",
        "correct": false
      },
      {
        "text": "accepting a hardware interrupt",
        "correct": true
      },
      {
        "text": "jump with trace",
        "correct": true
      },
      {
        "text": "accepting a non-maskable interrupt",
        "correct": true
      }
    ]
  },
  {
    "question": "in round-robin scheduling, if each task is allotted a certain amount of time to execute, it is called:",
    "answers": [
      {
        "text": "batch time",
        "correct": false
      },
      {
        "text": "period",
        "correct": false
      },
      {
        "text": "work time",
        "correct": false
      },
      {
        "text": "time slice",
        "correct": true
      }
    ]
  },
  {
    "question": "multi-threading on a multi-processor machine:",
    "answers": [
      {
        "text": "increases concurrency",
        "correct": true
      },
      {
        "text": "can increase or decrease concurrency",
        "correct": false
      },
      {
        "text": "reduces concurrency",
        "correct": false
      },
      {
        "text": "does not affect concurrency",
        "correct": false
      }
    ]
  },
  {
    "question": "in what states can a task occur?",
    "answers": [
      {
        "text": "ready",
        "correct": true
      },
      {
        "text": "blocked",
        "correct": true
      },
      {
        "text": "current",
        "correct": true
      },
      {
        "text": "resetted",
        "correct": false
      }
    ]
  },
  {
    "question": "the direct resume rule means that:",
    "answers": [
      {
        "text": "the resuming process gets a critical region after the resumed process exits the monitor",
        "correct": false
      },
      {
        "text": "the resuming process applies for the critical region just like other processes on monitor input",
        "correct": true
      },
      {
        "text": "the resuming process loses the critical region",
        "correct": true
      }
    ]
  },
  {
    "question": "in a concurrent environment, the operating system decides which task the cpu gets, when, and for how long. this feature is called:",
    "answers": [
      {
        "text": "task management",
        "correct": false
      },
      {
        "text": "traffic management",
        "correct": false
      },
      {
        "text": "task scheduling",
        "correct": true
      },
      {
        "text": "task timetable planning",
        "correct": false
      }
    ]
  },
  {
    "question": "there are three processes in the system: c - calculation process (batch process performing complex calculations lasting several hours), t - text editor (user edits text document), k - compiler (the user compiles the program, e.g. in c++). assign processes to priorities in the operating system from the highest to the lowest priority.",
    "answers": [
      {
        "text": "highest - t",
        "correct": true
      },
      {
        "text": "intermediate - k",
        "correct": true
      },
      {
        "text": "lowest - c",
        "correct": true
      }
    ]
  },
  {
    "question": "general semaphore:",
    "answers": [
      {
        "text": "is a shared variable",
        "correct": true
      },
      {
        "text": "requires busy waiting",
        "correct": false
      },
      {
        "text": "is to perform only indivisible operations",
        "correct": true
      },
      {
        "text": "can be only non-negative",
        "correct": true
      }
    ]
  },
  {
    "question": "essential activity in the interrupt handling procedure (i.e., the activity for which the interrupt is issued) consists in:",
    "answers": [
      {
        "text": "saving the context of the interrupted process",
        "correct": false
      },
      {
        "text": "unlocking the process waiting for this interrupt",
        "correct": true
      },
      {
        "text": "blocking the process to wait for the next interrupt",
        "correct": false
      },
      {
        "text": "unlocking the process to handle this interrupt at a higher level of abstraction",
        "correct": false
      }
    ]
  },
  {
    "question": "when is the scheduler called?",
    "answers": [
      {
        "text": "at the request of a user task",
        "correct": false
      },
      {
        "text": "at the end of the execution of each kernel procedure",
        "correct": true
      },
      {
        "text": "at the start of execution of each kernel procedure",
        "correct": false
      },
      {
        "text": "when the scheduler decides itself",
        "correct": false
      }
    ]
  },
  {
    "question": "scheduler function is:",
    "answers": [
      {
        "text": "counting the cpu time used by tasks",
        "correct": false
      },
      {
        "text": "selecting a task to run",
        "correct": true
      },
      {
        "text": "scheduling tasks on the processor",
        "correct": false
      },
      {
        "text": "changing task priorities",
        "correct": false
      }
    ]
  },
  {
    "question": "the number of tasks performed on the system in a given time is:",
    "answers": [
      {
        "text": "efficiency",
        "correct": false
      },
      {
        "text": "utilization",
        "correct": false
      },
      {
        "text": "throughput",
        "correct": true
      },
      {
        "text": "response time",
        "correct": false
      }
    ]
  },
  {
    "question": "what is included in the context that must be maintained for a synchronous precision interrupt?",
    "answers": [
      {
        "text": "program counter",
        "correct": true
      },
      {
        "text": "instruction register",
        "correct": false
      },
      {
        "text": "collective or individual interrupt mask",
        "correct": true
      },
      {
        "text": "general purpose registers",
        "correct": true
      }
    ]
  },
  {
    "question": "which task queue can never be empty?",
    "answers": [
      {
        "text": "swept away tasks",
        "correct": false
      },
      {
        "text": "ready tasks",
        "correct": false
      },
      {
        "text": "suspended tasks",
        "correct": false
      },
      {
        "text": "running tasks",
        "correct": true
      }
    ]
  },
  {
    "question": "imprecise interrupts can be handled:",
    "answers": [
      {
        "text": "after clearing the pipeline from the instructions",
        "correct": true
      },
      {
        "text": "after saving the full state of the pipeline",
        "correct": true
      },
      {
        "text": "when new instructions are suspended to be fetched into the pipeline",
        "correct": false
      },
      {
        "text": "only when the program allows accepting interrupts",
        "correct": false
      }
    ]
  },
  {
    "question": "priority scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": false
      },
      {
        "text": "system with many process classes",
        "correct": true
      },
      {
        "text": "time-sharing system",
        "correct": false
      }
    ]
  },
  {
    "question": "using test-and-set or compare-and-swap in synchronization:",
    "answers": [
      {
        "text": "it requires processes to actively wait",
        "correct": true
      },
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "it can only be applied in systems with shared memory",
        "correct": true
      },
      {
        "text": "stops the processor if 0 is read",
        "correct": false
      }
    ]
  },
  {
    "question": "context switch is:",
    "answers": [
      {
        "text": "writing registers to the task stack and retrieving them from another task stack",
        "correct": true
      },
      {
        "text": "switching to the system stack",
        "correct": false
      },
      {
        "text": "calling the kernel of the operating system",
        "correct": false
      },
      {
        "text": "extracode execution",
        "correct": false
      }
    ]
  },
  {
    "question": "in indulgent scheduling, the process keeps the cpu until:",
    "answers": [
      {
        "text": "waiving",
        "correct": true
      },
      {
        "text": "next interrupt from the device",
        "correct": false
      },
      {
        "text": "next interrupt from the timer",
        "correct": false
      },
      {
        "text": "termination",
        "correct": true
      }
    ]
  },
  {
    "question": "at the suspended state is a process that:",
    "answers": [
      {
        "text": "waits for an i/o operation to complete",
        "correct": true
      },
      {
        "text": "waits for a processor",
        "correct": false
      },
      {
        "text": "fills the processor idle time",
        "correct": false
      },
      {
        "text": "occupies a processor",
        "correct": false
      }
    ]
  },
  {
    "question": "conditional variables in a monitor",
    "answers": [
      {
        "text": "they guard access to the critical region of the monitor",
        "correct": false
      },
      {
        "text": "they are used to suspend processes that cannot run because the conditions for their continuation are not met",
        "correct": true
      },
      {
        "text": "they are used to check whether the conditions for process continuation are met",
        "correct": false
      }
    ]
  },
  {
    "question": "round-robin scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "time-sharing system",
        "correct": true
      },
      {
        "text": "real-time system",
        "correct": false
      },
      {
        "text": "system with different classes of tasks",
        "correct": false
      },
      {
        "text": "every system",
        "correct": false
      }
    ]
  },
  {
    "question": "the direct resume rule means that:",
    "answers": [
      {
        "text": "the resuming process gets a critical region after the resumed process exits the critical region",
        "correct": false
      },
      {
        "text": "the resuming process loses the critical region",
        "correct": true
      },
      {
        "text": "the resuming process applies for the critical region just like other processes waiting to enter the critical region",
        "correct": true
      }
    ]
  },
  {
    "question": "system/user threads:",
    "answers": [
      {
        "text": "user-level threads share the same stack",
        "correct": false
      },
      {
        "text": "system level thread descriptors are stored in the program address space",
        "correct": false
      },
      {
        "text": "user-level threads share the same execution context",
        "correct": true
      }
    ]
  },
  {
    "question": "the number of tasks performed on the system in a given time is:",
    "answers": [
      {
        "text": "response time",
        "correct": false
      },
      {
        "text": "utilization",
        "correct": false
      },
      {
        "text": "throughput",
        "correct": true
      },
      {
        "text": "efficiency",
        "correct": false
      }
    ]
  },
  {
    "question": "to end the interrupt service, use the following instruction:",
    "answers": [
      {
        "text": "regular jump instruction",
        "correct": false
      },
      {
        "text": "special return instruction",
        "correct": true
      },
      {
        "text": "return from subroutine call",
        "correct": false
      },
      {
        "text": "none - the processor will end the service automatically",
        "correct": false
      }
    ]
  },
  {
    "question": "the microkernel of the operating system performs the following role:",
    "answers": [
      {
        "text": "runs programs",
        "correct": false
      },
      {
        "text": "it receives interrupts and routes them to the appropriate drivers and other layers of the system",
        "correct": true
      },
      {
        "text": "synchronizes processes",
        "correct": true
      }
    ]
  },
  {
    "question": "in multi-level interrupts (vectored interrupts) the jump is performed:",
    "answers": [
      {
        "text": "to a fixed address",
        "correct": false
      },
      {
        "text": "to the address contained in the device driver, provided by the i/o instruction",
        "correct": false
      },
      {
        "text": "to the address specified in the given processor register",
        "correct": false
      },
      {
        "text": "according to the table indexed by the interrupt number",
        "correct": true
      }
    ]
  },
  {
    "question": "by definition, a deadlock is a situation where:",
    "answers": [
      {
        "text": "at least two processes are waiting for conditions that cannot be met",
        "correct": false
      },
      {
        "text": "any greater than zero number of processes are waiting for conditions that cannot be met",
        "correct": true
      },
      {
        "text": "any greater than one number of processes are waiting for conditions that cannot be met",
        "correct": false
      },
      {
        "text": "exactly two processes are waiting for conditions that cannot be met",
        "correct": false
      }
    ]
  },
  {
    "question": "what can happen when a job leaves the critical section and more than 1 task is waiting for the critical section?",
    "answers": [
      {
        "text": "deadlock waiting for critical section",
        "correct": false
      },
      {
        "text": "letting both tasks into the critical section",
        "correct": false
      },
      {
        "text": "active waiting for a critical section",
        "correct": false
      },
      {
        "text": "starvation awaiting a critical section",
        "correct": true
      }
    ]
  },
  {
    "question": "how does the operating system call the task completion subroutine?",
    "answers": [
      {
        "text": "sets the trace in the terminating subroutine to the current position - 2",
        "correct": true
      },
      {
        "text": "builds the frame of the terminating subroutine on the task stack - 3",
        "correct": true
      },
      {
        "text": "recreates the context programmatically and executes the iret instruction - 4",
        "correct": true
      },
      {
        "text": "builds an interrupt vector on the system stack pointing to the terminating subroutine code - 1",
        "correct": true
      }
    ]
  },
  {
    "question": "scheduling algorithms can be:",
    "answers": [
      {
        "text": "indulgent",
        "correct": true
      },
      {
        "text": "interrupting",
        "correct": false
      },
      {
        "text": "preemptive",
        "correct": true
      },
      {
        "text": "term changing",
        "correct": false
      }
    ]
  },
  {
    "question": "the process context includes:",
    "answers": [
      {
        "text": "general purpose registers",
        "correct": true
      },
      {
        "text": "process descriptor",
        "correct": true
      },
      {
        "text": "external device registers",
        "correct": false
      },
      {
        "text": "code and data",
        "correct": true
      }
    ]
  },
  {
    "question": "round-robin scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "system with different classes of tasks",
        "correct": false
      },
      {
        "text": "time-sharing system",
        "correct": true
      },
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": false
      }
    ]
  },
  {
    "question": "two successive executions of operation v in one process on a binary semaphore in down state:",
    "answers": [
      {
        "text": "it doesn't change anything",
        "correct": false
      },
      {
        "text": "increases semaphore value by 2",
        "correct": false
      },
      {
        "text": "raises the semaphore if there are no suspended processes",
        "correct": true
      },
      {
        "text": "if the semaphore guards a critical region, it can let two processes enter the critical region",
        "correct": true
      }
    ]
  },
  {
    "question": "in a multitasking environment, the operating system decides which task the cpu gets, when, and for how long. this feature is called:",
    "answers": [
      {
        "text": "traffic control",
        "correct": false
      },
      {
        "text": "task management",
        "correct": false
      },
      {
        "text": "task timetable management",
        "correct": false
      },
      {
        "text": "task scheduling",
        "correct": true
      }
    ]
  },
  {
    "question": "when starting a program, how is control passed to it from the operating system?",
    "answers": [
      {
        "text": "extracode",
        "correct": false
      },
      {
        "text": "return from interrupt handler iret",
        "correct": true
      },
      {
        "text": "jump with trace",
        "correct": false
      },
      {
        "text": "jump",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following statements applies to the process?",
    "answers": [
      {
        "text": "a process is defined as a set of resources needed to run a program",
        "correct": true
      },
      {
        "text": "the execution of the process must proceed in a sequential manner",
        "correct": true
      },
      {
        "text": "a process is a running program",
        "correct": true
      },
      {
        "text": "a process is code and data loaded into main memory",
        "correct": false
      }
    ]
  },
  {
    "question": "the purpose of mutual exclusion is:",
    "answers": [
      {
        "text": "deadlock prevention",
        "correct": false
      },
      {
        "text": "obtaining exclusive access",
        "correct": true
      },
      {
        "text": "secure context switch",
        "correct": false
      },
      {
        "text": "interrupt service",
        "correct": false
      }
    ]
  },
  {
    "question": "inter-process communication can be organized using:",
    "answers": [
      {
        "text": "shared memory fields accessible through system calls",
        "correct": true
      },
      {
        "text": "shared directly addressable memory fields",
        "correct": true
      },
      {
        "text": "messages",
        "correct": true
      },
      {
        "text": "interrupts",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt vector:",
    "answers": [
      {
        "text": "contains minimal information that cannot be saved programmatically",
        "correct": true
      },
      {
        "text": "it is saved automatically when an interrupt is accepted",
        "correct": true
      },
      {
        "text": "contains the instruction counter, condition bits, interrupt mask, and general purpose registers",
        "correct": false
      },
      {
        "text": "contains the id of the process that should be restarted",
        "correct": false
      }
    ]
  },
  {
    "question": "what does it mean that the interrupt subsystem is vectored (all components of the correct answer must be given)?",
    "answers": [
      {
        "text": "interrupts are accepted on multiple input lines",
        "correct": true
      },
      {
        "text": "there is an interrupt handling table indexed by the interrupt line number",
        "correct": true
      },
      {
        "text": "there is an individual interrupt mask",
        "correct": true
      },
      {
        "text": "uses interrupt vector in interrupt handling",
        "correct": false
      }
    ]
  },
  {
    "question": "the interrupt encoder is:",
    "answers": [
      {
        "text": "a combinational circuit that computes the number of the reported and unmasked interrupt with the highest priority",
        "correct": true
      },
      {
        "text": "a register that tells the processor the interrupt number to be handled",
        "correct": false
      },
      {
        "text": "a combinational circuit that calculates the value of a new individual interrupt mask",
        "correct": true
      },
      {
        "text": "a combinational circuit that transmits to the processor the number of the interrupt to be serviced",
        "correct": true
      }
    ]
  },
  {
    "question": "with indulgent scheduling, once a cpu is allocated to a task, the task keeps it until:",
    "answers": [
      {
        "text": "task termination",
        "correct": true
      },
      {
        "text": "transition a task from the active state to the ready state",
        "correct": false
      },
      {
        "text": "releasing the processor by the task",
        "correct": true
      },
      {
        "text": "transition a task from the ready state to the active state",
        "correct": false
      }
    ]
  },
  {
    "question": "indulgent scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "system with many process classes",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": true
      },
      {
        "text": "time-sharing system",
        "correct": false
      }
    ]
  },
  {
    "question": "sjf selects the task:",
    "answers": [
      {
        "text": "which was first placed in the queue",
        "correct": false
      },
      {
        "text": "with the least cpu requirement",
        "correct": true
      },
      {
        "text": "which was last placed in the queue",
        "correct": false
      },
      {
        "text": "who waited the longest in the queue",
        "correct": false
      }
    ]
  },
  {
    "question": "which scheduling is used to organize concurrency?",
    "answers": [
      {
        "text": "long-term",
        "correct": false
      },
      {
        "text": "short-term",
        "correct": true
      },
      {
        "text": "preempting",
        "correct": false
      },
      {
        "text": "medium-term",
        "correct": false
      }
    ]
  },
  {
    "question": "in round-robin scheduling, if each task is allotted a certain amount of time to execute, it is called:",
    "answers": [
      {
        "text": "period",
        "correct": false
      },
      {
        "text": "batch time",
        "correct": false
      },
      {
        "text": "work time",
        "correct": false
      },
      {
        "text": "time slice",
        "correct": true
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors",
    "answers": [
      {
        "text": "4,0",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is part of batch systems?",
    "answers": [
      {
        "text": "medium-term scheduler",
        "correct": true
      },
      {
        "text": "no scheduler is needed",
        "correct": false
      },
      {
        "text": "long-term scheduler",
        "correct": true
      },
      {
        "text": "short-term scheduler",
        "correct": false
      }
    ]
  },
  {
    "question": "the test-and-set or compare-and-swap instruction has the following characteristics:",
    "answers": [
      {
        "text": "requires active waiting from tasks",
        "correct": true
      },
      {
        "text": "it is possible to use only in 1-processor systems",
        "correct": false
      },
      {
        "text": "it is possible to deadlock with tas/cas operations on multiple variables",
        "correct": true
      },
      {
        "text": "it is possible to use only on computers with common memory",
        "correct": true
      }
    ]
  },
  {
    "question": "what are the sequence of actions in interrupt handling?",
    "answers": [
      {
        "text": "saving a copy of the interrupt vector (pc and sr) - 1",
        "correct": true
      },
      {
        "text": "switching to system mode (modification of pc and status register) - 2",
        "correct": true
      },
      {
        "text": "programmatic context saving - 3",
        "correct": true
      },
      {
        "text": "switching to the system stack - 4",
        "correct": true
      }
    ]
  },
  {
    "question": "in the philosophers problem, if there are 4 of them:",
    "answers": [
      {
        "text": "deadlock is not possible",
        "correct": false
      },
      {
        "text": "starvation is not possible",
        "correct": true
      },
      {
        "text": "starvation is possible",
        "correct": false
      },
      {
        "text": "deadlock is possible",
        "correct": true
      }
    ]
  },
  {
    "question": "after accepting an interrupt, the next interrupts are:",
    "answers": [
      {
        "text": "unblocked",
        "correct": false
      },
      {
        "text": "partly blocked, partly unblocked, according to the level of the accepted interrupt",
        "correct": false
      },
      {
        "text": "blocked",
        "correct": true
      },
      {
        "text": "some blocked, some unblocked, developer decides",
        "correct": false
      }
    ]
  },
  {
    "question": "how is exception identification performed?",
    "answers": [
      {
        "text": "the specification of hardware interrupts is given over the data bus",
        "correct": true
      },
      {
        "text": "all exceptions are specified using the data bus",
        "correct": false
      },
      {
        "text": "the specification of hardware interrupts and traps is given over the data bus",
        "correct": false
      },
      {
        "text": "the specification of hardware interrupts and errors is given over the data bus",
        "correct": false
      }
    ]
  },
  {
    "question": "the kernel (microkernel) is responsible for:",
    "answers": [
      {
        "text": "task control",
        "correct": true
      },
      {
        "text": "interrupt handling (at the elementary level, then they are passed on to other layers)",
        "correct": true
      },
      {
        "text": "memory allocation and freeing",
        "correct": false
      },
      {
        "text": "synchronization of processes and devices with processes",
        "correct": true
      }
    ]
  },
  {
    "question": "the process context includes:",
    "answers": [
      {
        "text": "general purpose registers",
        "correct": true
      },
      {
        "text": "process descriptor",
        "correct": false
      },
      {
        "text": "external devices registers",
        "correct": false
      },
      {
        "text": "the content of the file containing the program",
        "correct": false
      }
    ]
  },
  {
    "question": "when an exception is raised in user mode, the operating system switches to the kernel system stack, and what happens when an exception is raised in system mode?",
    "answers": [
      {
        "text": "initializes the kernel system stack from the scratch",
        "correct": false
      },
      {
        "text": "switches back to the application program stack",
        "correct": false
      },
      {
        "text": "nothing special, it builds the context on the kernel system stack",
        "correct": true
      },
      {
        "text": "switches to the next kernel system stack",
        "correct": false
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors",
    "answers": [
      {
        "text": "4,0",
        "correct": true
      }
    ]
  },
  {
    "question": "the test-and-set or compare-and-swap instruction has the following characteristics:",
    "answers": [
      {
        "text": "requires active waiting from tasks",
        "correct": true
      },
      {
        "text": "it is possible to use only in 1-processor systems",
        "correct": false
      },
      {
        "text": "it is possible to deadlock with tas/cas operations on multiple variables",
        "correct": true
      },
      {
        "text": "it is possible to use only on computers with common memory",
        "correct": true
      }
    ]
  },
  {
    "question": "what are the sequence of actions in interrupt handling?",
    "answers": [
      {
        "text": "saving a copy of the interrupt vector (pc and sr)",
        "correct": true
      },
      {
        "text": "switching to system mode (modification of pc and status register)",
        "correct": true
      },
      {
        "text": "programmatic context saving",
        "correct": true
      },
      {
        "text": "switching to the system stack",
        "correct": true
      }
    ]
  },
  {
    "question": "in the philosophers problem, if there are 4 of them:",
    "answers": [
      {
        "text": "deadlock is not possible",
        "correct": false
      },
      {
        "text": "starvation is not possible",
        "correct": true
      },
      {
        "text": "starvation is possible",
        "correct": false
      },
      {
        "text": "deadlock is possible",
        "correct": true
      }
    ]
  },
  {
    "question": "after accepting an interrupt, the next interrupts are:",
    "answers": [
      {
        "text": "unblocked",
        "correct": false
      },
      {
        "text": "partly blocked, partly unblocked, according to the level of the accepted interrupt",
        "correct": false
      },
      {
        "text": "blocked",
        "correct": true
      },
      {
        "text": "some blocked, some unblocked, developer decides",
        "correct": false
      }
    ]
  },
  {
    "question": "how is exception identification performed?",
    "answers": [
      {
        "text": "the specification of hardware interrupts is given over the data bus",
        "correct": true
      },
      {
        "text": "all exceptions are specified using the data bus",
        "correct": false
      },
      {
        "text": "the specification of hardware interrupts and traps is given over the data bus",
        "correct": false
      },
      {
        "text": "the specification of hardware interrupts and errors is given over the data bus",
        "correct": false
      }
    ]
  },
  {
    "question": "the process context includes:",
    "answers": [
      {
        "text": "general purpose registers",
        "correct": true
      },
      {
        "text": "process descriptor",
        "correct": false
      },
      {
        "text": "external devices registers",
        "correct": false
      },
      {
        "text": "the content of the file containing the program",
        "correct": false
      }
    ]
  },
  {
    "question": "at the suspended state is a process that:",
    "answers": [
      {
        "text": "fills the processor idle time",
        "correct": false
      },
      {
        "text": "waits for the processor",
        "correct": false
      },
      {
        "text": "occupation and processor",
        "correct": false
      },
      {
        "text": "waits for an i/o operation to complete",
        "correct": true
      }
    ]
  },
  {
    "question": "at the blocked state is a process that:",
    "answers": [
      {
        "text": "occupies a processor",
        "correct": false
      },
      {
        "text": "waits for a processor",
        "correct": false
      },
      {
        "text": "waits for an i/o operation to complete",
        "correct": true
      },
      {
        "text": "fills the processor idle time",
        "correct": false
      }
    ]
  },
  {
    "question": "operation v on a raised binary semaphore:",
    "answers": [
      {
        "text": "it does not change the value of the semaphore",
        "correct": true
      },
      {
        "text": "it is stored in order to be able to perform as many operations p as there were v",
        "correct": false
      },
      {
        "text": "increases semaphore value by 1",
        "correct": false
      }
    ]
  },
  {
    "question": "individual interrupt mask:",
    "answers": [
      {
        "text": "a register whose bits are anded (conjunction) with the bits from the interrupt request register",
        "correct": true
      },
      {
        "text": "a combinational circuit that calculates the number of the interrupt received",
        "correct": false
      },
      {
        "text": "register in which addresses of devices reporting individual interrupts are stored",
        "correct": false
      },
      {
        "text": "a register whose bits are ored (alternative) with the bits from the interrupt request register",
        "correct": false
      }
    ]
  },
  {
    "question": "scheduling algorithms can be:",
    "answers": [
      {
        "text": "preemptive",
        "correct": true
      },
      {
        "text": "term changing",
        "correct": false
      },
      {
        "text": "interrupting",
        "correct": false
      },
      {
        "text": "indulgent",
        "correct": true
      }
    ]
  },
  {
    "question": "the optimal scheduling algorithm in terms of minimizing the average time in the system of a given task is:",
    "answers": [
      {
        "text": "fcfs",
        "correct": false
      },
      {
        "text": "time slicing",
        "correct": false
      },
      {
        "text": "sjf",
        "correct": true
      },
      {
        "text": "priority",
        "correct": false
      }
    ]
  },
  {
    "question": "sequence of actions when starting a new task:",
    "answers": [
      {
        "text": "filling in the descriptor in the kernel - 1",
        "correct": true
      },
      {
        "text": "memory allocation if this is the first task of the program - 2",
        "correct": true
      },
      {
        "text": "initialize the stack, fill the first frame - 3",
        "correct": true
      },
      {
        "text": "instruction to transfer control to the task - 4",
        "correct": true
      }
    ]
  },
  {
    "question": "which of the following applies to user-level threads?",
    "answers": [
      {
        "text": "user-level threads require their descriptors in the kernel",
        "correct": false
      },
      {
        "text": "user-level threads can themselves be multi-threaded",
        "correct": false
      },
      {
        "text": "user-level threads cost no execution time in system mode",
        "correct": true
      },
      {
        "text": "the organization of user-level threads is specific to the operating system",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt handling - sequence of actions:",
    "answers": [
      {
        "text": "saving a copy of the interrupt vector (pc and sr) - 1",
        "correct": true
      },
      {
        "text": "switching to system mode (modification of pc and status register) - 2",
        "correct": true
      },
      {
        "text": "programmatic context saving - 3",
        "correct": true
      },
      {
        "text": "switching to the system stack - 3",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is used to preserve the states of preempted tasks?",
    "answers": [
      {
        "text": "context switch",
        "correct": true
      },
      {
        "text": "task period",
        "correct": false
      },
      {
        "text": "time slice",
        "correct": false
      },
      {
        "text": "batch work",
        "correct": false
      }
    ]
  },
  {
    "question": "semaphore function is to:",
    "answers": [
      {
        "text": "process scheduling",
        "correct": false
      },
      {
        "text": "memory management",
        "correct": false
      },
      {
        "text": "synchronize critical resources to prevent deadlock",
        "correct": true
      },
      {
        "text": "synchronize processes for better cpu utilization",
        "correct": false
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors",
    "answers": [
      {
        "text": "4",
        "correct": true
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 4 processors",
    "answers": [
      {
        "text": "3.4",
        "correct": true
      }
    ]
  },
  {
    "question": "which mechanism is a part of time-sharing systems?",
    "answers": [
      {
        "text": "short-term scheduler",
        "correct": true
      },
      {
        "text": "no scheduler is needed",
        "correct": false
      },
      {
        "text": "long-term scheduler",
        "correct": false
      },
      {
        "text": "medium-term scheduler",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt handling - sequence of actions:",
    "answers": [
      {
        "text": "1. → saving a copy of the interrupt vector (pc and sr)",
        "correct": true
      },
      {
        "text": "2. → switching to system mode (modification of pc and status register)",
        "correct": true
      },
      {
        "text": "3. → programmatic context saving",
        "correct": true
      },
      {
        "text": "4. → switching to the system stack",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is used to preserve the states of preempted tasks?",
    "answers": [
      {
        "text": "context switch",
        "correct": true
      },
      {
        "text": "task period",
        "correct": false
      },
      {
        "text": "time slice",
        "correct": false
      },
      {
        "text": "batch work",
        "correct": false
      }
    ]
  },
  {
    "question": "when the processor is released, the scheduler selects one of the queued processes:",
    "answers": [
      {
        "text": "suspended",
        "correct": false
      },
      {
        "text": "running",
        "correct": false
      },
      {
        "text": "waiting",
        "correct": false
      },
      {
        "text": "ready",
        "correct": true
      }
    ]
  },
  {
    "question": "which scheduler is also called a job planner?",
    "answers": [
      {
        "text": "short-term",
        "correct": false
      },
      {
        "text": "auxiliary",
        "correct": false
      },
      {
        "text": "medium-term",
        "correct": false
      },
      {
        "text": "long-term",
        "correct": true
      }
    ]
  },
  {
    "question": "semaphore function is to:",
    "answers": [
      {
        "text": "process scheduling",
        "correct": false
      },
      {
        "text": "memory management",
        "correct": false
      },
      {
        "text": "synchronize critical resources to prevent deadlock",
        "correct": true
      },
      {
        "text": "synchronize processes for better cpu utilization",
        "correct": false
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors",
    "answers": [
      {
        "text": "4",
        "correct": true
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 4 processors",
    "answers": [
      {
        "text": "3.4",
        "correct": true
      }
    ]
  },
  {
    "question": "scheduling aims to optimize:",
    "answers": [
      {
        "text": "processor utilization",
        "correct": true
      },
      {
        "text": "system throughput",
        "correct": true
      },
      {
        "text": "wait time",
        "correct": true
      },
      {
        "text": "reaction time",
        "correct": true
      }
    ]
  },
  {
    "question": "interrupt handling - sequence of actions:",
    "answers": [
      {
        "text": "1. → saving a copy of the interrupt vector (pc and sr)",
        "correct": true
      },
      {
        "text": "2. → switching to system mode (modification of pc and status register)",
        "correct": true
      },
      {
        "text": "3. → programmatic context saving",
        "correct": true
      },
      {
        "text": "4. → switching to the system stack",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is used to preserve the states of preempted tasks?",
    "answers": [
      {
        "text": "context switch",
        "correct": true
      },
      {
        "text": "task period",
        "correct": false
      },
      {
        "text": "time slice",
        "correct": false
      },
      {
        "text": "batch work",
        "correct": false
      }
    ]
  },
  {
    "question": "semaphore function is to:",
    "answers": [
      {
        "text": "process scheduling",
        "correct": false
      },
      {
        "text": "memory management",
        "correct": false
      },
      {
        "text": "synchronize critical resources to prevent deadlock",
        "correct": true
      },
      {
        "text": "synchronize processes for better cpu utilization",
        "correct": false
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors",
    "answers": [
      {
        "text": "4",
        "correct": true
      }
    ]
  },
  {
    "question": "the multi-level interrupt controller includes:",
    "answers": [
      {
        "text": "collective interrupt mask",
        "correct": true
      },
      {
        "text": "priority encoder",
        "correct": true
      },
      {
        "text": "individual interrupt mask",
        "correct": true
      },
      {
        "text": "the register of interrupt being serviced",
        "correct": false
      },
      {
        "text": "interrupt request register",
        "correct": true
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 4 processors",
    "answers": [
      {
        "text": "3.4",
        "correct": true
      }
    ]
  },
  {
    "question": "the number of condition variables is by definition in the monitor:",
    "answers": [
      {
        "text": "two",
        "correct": false
      },
      {
        "text": "one",
        "correct": false
      },
      {
        "text": "as many as there are different conditions for the continuation of processes",
        "correct": true
      },
      {
        "text": "as many as there are different conditions for the continuation of processes plus one for mutual exclusion",
        "correct": false
      }
    ]
  },
  {
    "question": "the following situations trigger \"error\" exceptions:",
    "answers": [
      {
        "text": "attempting to execute an illegal instruction",
        "correct": true
      },
      {
        "text": "attempting to execute in user mode an instruction that is only legal in system mode",
        "correct": true
      },
      {
        "text": "page fault (also known as frame fault, frame error, page miss)",
        "correct": false
      },
      {
        "text": "extracode",
        "correct": false
      }
    ]
  },
  {
    "question": "using the test-and-set instruction in synchronization:",
    "answers": [
      {
        "text": "it requires processes to actively wait",
        "correct": true
      },
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "stops the processor if io is read",
        "correct": false
      }
    ]
  },
  {
    "question": "during the interrupt handling:",
    "answers": [
      {
        "text": "other interrupts can be accepted",
        "correct": false
      },
      {
        "text": "other interrupts may or may not be accepted at the discretion of the programmer",
        "correct": true
      },
      {
        "text": "other interrupts are disabled",
        "correct": false
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 3 processors",
    "answers": [
      {
        "text": "4.1",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is used to save and restore the task state?",
    "answers": [
      {
        "text": "context switch",
        "correct": true
      },
      {
        "text": "task descriptor",
        "correct": false
      },
      {
        "text": "applications counter",
        "correct": false
      },
      {
        "text": "scheduling data",
        "correct": false
      }
    ]
  },
  {
    "question": "the following situations trigger \"error\" exceptions:",
    "answers": [
      {
        "text": "a reference to memory that is not in the program address space",
        "correct": true
      },
      {
        "text": "memory reference in the area of the page that is not in memory",
        "correct": false
      },
      {
        "text": "an attempt to execute an instruction from the area of the page for which the 'no code' bit was set",
        "correct": true
      },
      {
        "text": "memory reference beyond limit register value",
        "correct": true
      }
    ]
  },
  {
    "question": "semaphores are used to solve the problem:",
    "answers": [
      {
        "text": "belady problem",
        "correct": false
      },
      {
        "text": "races",
        "correct": false
      },
      {
        "text": "process scheduling",
        "correct": false
      },
      {
        "text": "mutual exclusion",
        "correct": true
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors",
    "answers": [
      {
        "text": "4.4",
        "correct": true
      }
    ]
  },
  {
    "question": "what exception (software or hardware interrupt) causes system mode if user mode is current?",
    "answers": [
      {
        "text": "any exception",
        "correct": true
      },
      {
        "text": "it depends what type of exception",
        "correct": false
      },
      {
        "text": "synchronous yes, asynchronous no",
        "correct": false
      },
      {
        "text": "no exception",
        "correct": false
      }
    ]
  },
  {
    "question": "the difference between trap and error is:",
    "answers": [
      {
        "text": "there is no significant difference",
        "correct": false
      },
      {
        "text": "the error is issued by hardware and the trap by software",
        "correct": false
      },
      {
        "text": "errors are generally reported asynchronously and traps synchronously",
        "correct": true
      },
      {
        "text": "after an error, there is usually no return to the program, and after a trap, yes",
        "correct": true
      }
    ]
  },
  {
    "question": "how does the operating system call the task completion subroutine?",
    "answers": [
      {
        "text": "recreates the context programmatically and executes the iret instruction - 2",
        "correct": true
      },
      {
        "text": "sets the trace in the terminating subroutine to the current position - 2",
        "correct": true
      },
      {
        "text": "builds an interrupt vector on the system stack pointing to the terminating subroutine code - 3",
        "correct": true
      },
      {
        "text": "builds the frame of the terminating subroutine on the task stack - 1",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is part of time-sharing systems?",
    "answers": [
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "medium-term scheduler",
        "correct": false
      },
      {
        "text": "long-term scheduler",
        "correct": false
      },
      {
        "text": "short-term scheduler",
        "correct": true
      }
    ]
  },
  {
    "question": "in the 'current' state, there is a process that:",
    "answers": [
      {
        "text": "fills the cpu idle time",
        "correct": false
      },
      {
        "text": "waits for a processor",
        "correct": false
      },
      {
        "text": "occupies a processor",
        "correct": true
      },
      {
        "text": "waits for an i/o operation to complete",
        "correct": false
      }
    ]
  },
  {
    "question": "at the ready state is a process that:",
    "answers": [
      {
        "text": "waits for an i/o operation to complete",
        "correct": false
      },
      {
        "text": "waits for a processor",
        "correct": true
      },
      {
        "text": "occupies a processor",
        "correct": false
      },
      {
        "text": "fills the processor idle time",
        "correct": false
      }
    ]
  },
  {
    "question": "a process can appear in the pool of scheduling processes as a result of:",
    "answers": [
      {
        "text": "starting a new process",
        "correct": true
      },
      {
        "text": "performing the p operation on the semaphore",
        "correct": false
      },
      {
        "text": "performing v operation on the semaphore",
        "correct": true
      },
      {
        "text": "completing an i/o operation",
        "correct": true
      }
    ]
  },
  {
    "question": "in a multiprocessor operating system, interrupt blocking is sufficient to prevent the microkernel from executing its routines simultaneously:",
    "answers": [
      {
        "text": "true",
        "correct": false
      },
      {
        "text": "false",
        "correct": true
      }
    ]
  },
  {
    "question": "twice consecutive execution in one process of operation p on a raised binary semaphore:",
    "answers": [
      {
        "text": "causes the semaphore to get down",
        "correct": true
      },
      {
        "text": "it doesn’t change anything",
        "correct": false
      },
      {
        "text": "decreases semaphore value by 2",
        "correct": false
      },
      {
        "text": "if a semaphore guards a critical region, it leads to a deadlock",
        "correct": true
      }
    ]
  },
  {
    "question": "what is true for simultaneous execution in the same context?",
    "answers": [
      {
        "text": "a multiprocessor kernel can be concurrent",
        "correct": true
      },
      {
        "text": "the shared context forces threads to run on the same processor",
        "correct": false
      },
      {
        "text": "the use of threads ensures concurrency within the process",
        "correct": true
      },
      {
        "text": "threads minimize context switch time",
        "correct": true
      }
    ]
  },
  {
    "question": "devices report their readiness by:",
    "answers": [
      {
        "text": "issuing an interrupt",
        "correct": true
      },
      {
        "text": "unblocking the interrupts",
        "correct": false
      },
      {
        "text": "system call",
        "correct": false
      },
      {
        "text": "setting a status bit",
        "correct": true
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors",
    "answers": [
      {
        "text": "4.3",
        "correct": true
      }
    ]
  },
  {
    "question": "what is true about system level threads?",
    "answers": [
      {
        "text": "all process threads can share the same set of child processes",
        "correct": true
      },
      {
        "text": "all process threads share the same address space",
        "correct": true
      },
      {
        "text": "all process threads can share the same set of open files",
        "correct": true
      },
      {
        "text": "thread switching does not require interaction with the operating system",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following information is stored on task switching?",
    "answers": [
      {
        "text": "contents of general purpose registers, program counter, and similar registers available to the program",
        "correct": true
      },
      {
        "text": "contents of the instruction register and similar registers",
        "correct": false
      },
      {
        "text": "scheduler data",
        "correct": true
      },
      {
        "text": "i/o status information",
        "correct": true
      }
    ]
  },
  {
    "question": "context switch is caused by:",
    "answers": [
      {
        "text": "relocation",
        "correct": false
      },
      {
        "text": "input/output operations",
        "correct": false
      },
      {
        "text": "paging",
        "correct": false
      },
      {
        "text": "interrupts",
        "correct": true
      }
    ]
  },
  {
    "question": "the return from interrupt instruction:",
    "answers": [
      {
        "text": "restores general purpose registers",
        "correct": false
      },
      {
        "text": "restores the stack pointer",
        "correct": false
      },
      {
        "text": "restores the interrupt vector",
        "correct": true
      },
      {
        "text": "always jumps to the process that was interrupted",
        "correct": false
      }
    ]
  },
  {
    "question": "the interrupt acceptance sequence consists of (in the sequence):",
    "answers": [
      {
        "text": "identification of the interrupt level, performing a jump with the trace according to the interrupt table, saving the interrupt vector",
        "correct": false
      },
      {
        "text": "identification of the interrupt level, saving the interrupt vector, performing a jump with a trace according to the interrupt table",
        "correct": true
      },
      {
        "text": "identification of the interrupt level, performing a jump according to the interrupt table, saving the interrupt vector",
        "correct": false
      },
      {
        "text": "identification of the interrupt level, saving the interrupt vector, performing a jump according to the interrupt table",
        "correct": false
      }
    ]
  },
  {
    "question": "the thread is also called:",
    "answers": [
      {
        "text": "overlay process",
        "correct": false
      },
      {
        "text": "heavy process",
        "correct": false
      },
      {
        "text": "lightweight process",
        "correct": true
      },
      {
        "text": "data process",
        "correct": false
      }
    ]
  },
  {
    "question": "imprecise interrupts are:",
    "answers": [
      {
        "text": "they are unblocked in any state of the processor, not just between executions of instructions",
        "correct": false
      },
      {
        "text": "they are transferred in any state of the processor, not just between the execution of successive instructions",
        "correct": false
      },
      {
        "text": "they are accepted in any state of the processor, not just between the execution of successive instructions",
        "correct": true
      },
      {
        "text": "they are issued in any state of the processor, not just between the execution of successive instructions",
        "correct": false
      }
    ]
  },
  {
    "question": "the kernel is _______ user-level threads.",
    "answers": [
      {
        "text": "creator",
        "correct": false
      },
      {
        "text": "unaware",
        "correct": true
      },
      {
        "text": "aware",
        "correct": false
      },
      {
        "text": "part",
        "correct": false
      }
    ]
  },
  {
    "question": "the result of cooperation of concurrent processes:",
    "answers": [
      {
        "text": "it can be non-deterministic",
        "correct": true
      },
      {
        "text": "it may depend on how processes are scheduled",
        "correct": true
      },
      {
        "text": "it is always deterministic",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following statements is true for system level threads?",
    "answers": [
      {
        "text": "user-level threads can be synchronized by the kernel",
        "correct": false
      },
      {
        "text": "multithreaded applications cannot use multiprocessing",
        "correct": false
      },
      {
        "text": "kernel-level threads require their descriptors in the kernel",
        "correct": true
      },
      {
        "text": "the threading implementation at the kernel level is done by the thread library attached to the program",
        "correct": false
      }
    ]
  },
  {
    "question": "the following situations cause \"error\" exceptions (processor internal interrupts)",
    "answers": [
      {
        "text": "extracode",
        "correct": false
      },
      {
        "text": "instruction legal but prohibited in user mode",
        "correct": true
      },
      {
        "text": "illegal instruction",
        "correct": true
      }
    ]
  },
  {
    "question": "cloning a process with a fork operation results in (not taking to account the numerical result of fork)?",
    "answers": [
      {
        "text": "duplication of code, data and stack segments",
        "correct": false
      },
      {
        "text": "duplication of data segment and stack segment",
        "correct": true
      },
      {
        "text": "duplication of code segment, initialization of new data segment and stack segment",
        "correct": false
      }
    ]
  },
  {
    "question": "the mechanism for moving programs between primary memory and mass storage is called:",
    "answers": [
      {
        "text": "sweeping",
        "correct": true
      },
      {
        "text": "leaching",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "leading out",
        "correct": false
      }
    ]
  },
  {
    "question": "when a suspended program is moved to auxiliary memory, its process state is called:",
    "answers": [
      {
        "text": "moved out",
        "correct": false
      },
      {
        "text": "exchanged",
        "correct": false
      },
      {
        "text": "swept away",
        "correct": true
      },
      {
        "text": "rinsed out",
        "correct": false
      }
    ]
  },
  {
    "question": "page thrashing is a phenomenon involving:",
    "answers": [
      {
        "text": "frequently changing the values of bits describing pages in frames",
        "correct": false
      },
      {
        "text": "frequent context changes that require page index tables to be reloaded to mmu cache",
        "correct": false
      },
      {
        "text": "frequent loading of pages that have just been ejected from memory",
        "correct": true
      },
      {
        "text": "loading the same page over and over again",
        "correct": false
      }
    ]
  },
  {
    "question": "which swapping algorithms can be implemented based on hardware support in the form of a collective reading of reference bits and collective clearing of these bits?",
    "answers": [
      {
        "text": "working set",
        "correct": false
      },
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "lru",
        "correct": true
      },
      {
        "text": "optimal",
        "correct": false
      },
      {
        "text": "no algorithm",
        "correct": false
      },
      {
        "text": "lfu",
        "correct": true
      },
      {
        "text": "second chance",
        "correct": false
      },
      {
        "text": "working set clock",
        "correct": false
      },
      {
        "text": "nru",
        "correct": false
      }
    ]
  },
  {
    "question": "in a multiprocessor operating system, interrupt blocking is sufficient to prevent the microkernel from executing its routines simultaneously",
    "answers": [
      {
        "text": "true",
        "correct": false
      },
      {
        "text": "false",
        "correct": true
      }
    ]
  },
  {
    "question": "twins algorithm:",
    "answers": [
      {
        "text": "causes internal fragmentation",
        "correct": true
      },
      {
        "text": "causes less fragmentation than static division into equal blocks",
        "correct": true
      },
      {
        "text": "causes external fragmentation",
        "correct": true
      }
    ]
  },
  {
    "question": "inter-process communication can be organized using:",
    "answers": [
      {
        "text": "messages",
        "correct": true
      },
      {
        "text": "shared directly addressable memory fields",
        "correct": true
      },
      {
        "text": "interrupts",
        "correct": false
      },
      {
        "text": "shared memory fields accessible through system calls",
        "correct": true
      }
    ]
  },
  {
    "question": "a multiprogram system is one that, in principle:",
    "answers": [
      {
        "text": "it allows you to store many programs in mass memory",
        "correct": false
      },
      {
        "text": "allows more than one program to run simultaneously",
        "correct": false
      },
      {
        "text": "it allows for running programs only one after another",
        "correct": false
      },
      {
        "text": "it allows for storing many programs in primary memory",
        "correct": true
      }
    ]
  },
  {
    "question": "the root directory of the disk should be located:",
    "answers": [
      {
        "text": "at a fixed address in main memory",
        "correct": false
      },
      {
        "text": "in a permanent place on the disk",
        "correct": false
      },
      {
        "text": "in a place hard-coded in the structures of the operating system",
        "correct": false
      },
      {
        "text": "in a place designated by the data structure in a fixed location on the disk",
        "correct": true
      }
    ]
  },
  {
    "question": "the following paging exceptions allow for returning to the program after they occur:",
    "answers": [
      {
        "text": "interrupt on write (iow)",
        "correct": true
      },
      {
        "text": "attempt to read from the frame storing the code",
        "correct": false
      },
      {
        "text": "attempting to write to a write-protected frame",
        "correct": false
      },
      {
        "text": "page fault",
        "correct": true
      }
    ]
  },
  {
    "question": "which technique was introduced because a single task could occupy both the cpu and i/o devices?",
    "answers": [
      {
        "text": "buffering",
        "correct": false
      },
      {
        "text": "interrupts",
        "correct": true
      },
      {
        "text": "multiprogramming",
        "correct": false
      },
      {
        "text": "preemptive scheduling",
        "correct": false
      }
    ]
  },
  {
    "question": "what is true about system level threads?",
    "answers": [
      {
        "text": "all process threads can share the same set of child processes.",
        "correct": true
      },
      {
        "text": "thread switching does not require interaction with the operating system.",
        "correct": false
      },
      {
        "text": "all process threads share the same address space.",
        "correct": true
      },
      {
        "text": "all process threads can share the same set of open files.",
        "correct": true
      }
    ]
  },
  {
    "question": "effective address is:",
    "answers": [
      {
        "text": "physical address",
        "correct": false
      },
      {
        "text": "logical address",
        "correct": true
      },
      {
        "text": "relative address",
        "correct": false
      },
      {
        "text": "indirect address",
        "correct": false
      }
    ]
  },
  {
    "question": "static relocation is performed by:",
    "answers": [
      {
        "text": "linker",
        "correct": true
      },
      {
        "text": "paging system",
        "correct": false
      },
      {
        "text": "loader",
        "correct": true
      },
      {
        "text": "special registers (datum)",
        "correct": false
      }
    ]
  },
  {
    "question": "on unix, the number of files is directly limited by:",
    "answers": [
      {
        "text": "i-node table size",
        "correct": true
      },
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "the size of the space allocated for files",
        "correct": true
      }
    ]
  },
  {
    "question": "in what states can a task occur?",
    "answers": [
      {
        "text": "resetted",
        "correct": false
      },
      {
        "text": "ready",
        "correct": true
      },
      {
        "text": "current",
        "correct": true
      },
      {
        "text": "blocked",
        "correct": true
      }
    ]
  },
  {
    "question": "in unix, the disk contains the following areas:",
    "answers": [
      {
        "text": "i-node table",
        "correct": true
      },
      {
        "text": "superblock",
        "correct": true
      },
      {
        "text": "directories",
        "correct": false
      },
      {
        "text": "files data",
        "correct": true
      }
    ]
  },
  {
    "question": "frame protection bits:",
    "answers": [
      {
        "text": "must be available for group clear",
        "correct": false
      },
      {
        "text": "must be readable",
        "correct": false
      },
      {
        "text": "must be group readable",
        "correct": false
      },
      {
        "text": "must be available for writing",
        "correct": true
      }
    ]
  },
  {
    "question": "for address translation, the following is used:",
    "answers": [
      {
        "text": "translation register",
        "correct": false
      },
      {
        "text": "associative translation buffer",
        "correct": true
      },
      {
        "text": "reference and protection bits",
        "correct": false
      },
      {
        "text": "index table",
        "correct": true
      }
    ]
  },
  {
    "question": "the conversion of the effective address to the physical one takes place:",
    "answers": [
      {
        "text": "in the memory management unit",
        "correct": true
      },
      {
        "text": "in the bus arbiter",
        "correct": false
      },
      {
        "text": "in the arithmetic-logic unit",
        "correct": false
      },
      {
        "text": "in the sequencer",
        "correct": false
      }
    ]
  },
  {
    "question": "two successive executions of operation v in one process on a binary semaphore in down state:",
    "answers": [
      {
        "text": "raises the semaphore if there are no suspended processes",
        "correct": true
      },
      {
        "text": "increases semaphore value by 2",
        "correct": false
      },
      {
        "text": "if the semaphore guards a critical region, it can lets two processes enter the critical region",
        "correct": true
      },
      {
        "text": "it doesn't change anything",
        "correct": false
      }
    ]
  },
  {
    "question": "the hardware mechanisms necessary for paging are (note: \"frame error\" is also called \"page fault\", \"frame fault\"):",
    "answers": [
      {
        "text": "address translation, page index tables, \"frame error\" interrupt",
        "correct": true
      },
      {
        "text": "address translation, page index tables, page reference bits, \"frame error\" interrupt",
        "correct": false
      },
      {
        "text": "address translation, page index tables, page reference bits, \"frame error\" interrupt, associative memory",
        "correct": false
      },
      {
        "text": "address translation, page index tables, \"frame error\" interrupt, associative memory, page swapper",
        "correct": false
      }
    ]
  },
  {
    "question": "context switch is caused by:",
    "answers": [
      {
        "text": "interrupts",
        "correct": true
      },
      {
        "text": "relocation",
        "correct": false
      },
      {
        "text": "paging",
        "correct": false
      },
      {
        "text": "input/output operations",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt request register is:",
    "answers": [
      {
        "text": "a register where interrupt line states are stored",
        "correct": true
      },
      {
        "text": "a register that blocks or unblocks all interrupts",
        "correct": false
      },
      {
        "text": "a combinational circuit that calculates the number of the interrupt received",
        "correct": false
      },
      {
        "text": "a register that blocks or unblocks individual interrupts",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is used to save and restore the task state?",
    "answers": [
      {
        "text": "applications counter",
        "correct": false
      },
      {
        "text": "task descriptor",
        "correct": false
      },
      {
        "text": "context switch",
        "correct": true
      },
      {
        "text": "scheduling data",
        "correct": false
      }
    ]
  },
  {
    "question": "the interrupt encoder is:",
    "answers": [
      {
        "text": "a combinational circuit that computes the number of the reported and unmasked interrupt with the highest priority",
        "correct": true
      },
      {
        "text": "a combinational circuit that transmits to the processor the number of the interrupt to be serviced",
        "correct": true
      },
      {
        "text": "a register that tells the processor the interrupt number to be handled",
        "correct": false
      },
      {
        "text": "a combinational circuit that calculates the value of a new individual interrupt mask",
        "correct": true
      }
    ]
  },
  {
    "question": "the direct resume rule means that:",
    "answers": [
      {
        "text": "the resuming process applies for the critical region just like other processes on monitor input",
        "correct": true
      },
      {
        "text": "the resuming process gets a critical region after the resumed process exits the monitor",
        "correct": false
      },
      {
        "text": "the resuming process loses the critical region",
        "correct": true
      }
    ]
  },
  {
    "question": "in the running state, there is a process that:",
    "answers": [
      {
        "text": "fills the cpu idle time",
        "correct": false
      },
      {
        "text": "waits for an i/o operation to complete",
        "correct": false
      },
      {
        "text": "waits for a processor",
        "correct": false
      },
      {
        "text": "occupies a processor",
        "correct": true
      }
    ]
  },
  {
    "question": "when is the scheduler called?",
    "answers": [
      {
        "text": "at the start of execution of each kernel procedure",
        "correct": false
      },
      {
        "text": "at the end of the execution of each kernel procedure",
        "correct": true
      },
      {
        "text": "at the request of a user task",
        "correct": false
      },
      {
        "text": "when the scheduler decides itself",
        "correct": false
      }
    ]
  },
  {
    "question": "a memory management technique in which the system divides memory into equal-sized chunks with virtual base addresses divisible by a chunk size, to easily manage relocation, is called:",
    "answers": [
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "fragmentation",
        "correct": false
      },
      {
        "text": "mapping",
        "correct": false
      },
      {
        "text": "paging",
        "correct": true
      }
    ]
  },
  {
    "question": "which swapping algorithms use page reference history?",
    "answers": [
      {
        "text": "working set clock",
        "correct": false
      },
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "nru",
        "correct": false
      },
      {
        "text": "lfu",
        "correct": true
      },
      {
        "text": "second chance",
        "correct": false
      },
      {
        "text": "lru",
        "correct": true
      },
      {
        "text": "working set",
        "correct": false
      }
    ]
  },
  {
    "question": "when an exception is raised in user mode, the operating system switches to the kernel system stack. what happens when an exception is raised in system mode?",
    "answers": [
      {
        "text": "switches to the next kernel system stack",
        "correct": false
      },
      {
        "text": "initializes the kernel system stack from scratch",
        "correct": false
      },
      {
        "text": "nothing special, it builds the context on the kernel system stack",
        "correct": true
      },
      {
        "text": "switches back to the application program stack",
        "correct": false
      }
    ]
  },
  {
    "question": "address translation mechanism:",
    "answers": [
      {
        "text": "adds the frame number to the page number",
        "correct": false
      },
      {
        "text": "concatenates the page number and page offset",
        "correct": false
      },
      {
        "text": "concatenates the frame number and page number",
        "correct": false
      },
      {
        "text": "concatenates the frame number and offset on the page",
        "correct": true
      }
    ]
  },
  {
    "question": "processor access scheduling decisions may be made under which of the following circumstances?",
    "answers": [
      {
        "text": "when a task goes from the waiting state to the ready state",
        "correct": true
      },
      {
        "text": "when a task terminates",
        "correct": true
      },
      {
        "text": "when a task transitions from the active state to the ready state",
        "correct": true
      },
      {
        "text": "when a task goes from the active state to the waiting state",
        "correct": true
      }
    ]
  },
  {
    "question": "if the compiler prepares a program with absolute addresses to be loaded in a fixed address space, it is called:",
    "answers": [
      {
        "text": "static compiling",
        "correct": false
      },
      {
        "text": "static loading",
        "correct": false
      },
      {
        "text": "static relocation",
        "correct": true
      },
      {
        "text": "static linking",
        "correct": false
      }
    ]
  },
  {
    "question": "the test-and-set or compare-and-swap instruction has the following characteristics:",
    "answers": [
      {
        "text": "it is possible to use only on computers with common memory",
        "correct": true
      },
      {
        "text": "it is possible to use only in 1-processor systems",
        "correct": false
      },
      {
        "text": "requires active waiting from tasks",
        "correct": true
      },
      {
        "text": "it is possible to deadlock with tas/cas operations on multiple variables",
        "correct": true
      }
    ]
  },
  {
    "question": "separate allocation queues for fixed memory blocks of different sizes cause:",
    "answers": [
      {
        "text": "internal fragmentation",
        "correct": true
      },
      {
        "text": "need for compaction",
        "correct": false
      },
      {
        "text": "external fragmentation",
        "correct": true
      }
    ]
  },
  {
    "question": "twice consecutive execution in one process of operation p on a raised binary semaphore:",
    "answers": [
      {
        "text": "if a semaphore guards a critical region, it leads to a deadlock",
        "correct": true
      },
      {
        "text": "decreases semaphore value by 2",
        "correct": false
      },
      {
        "text": "it doesn't change anything",
        "correct": false
      },
      {
        "text": "causes the semaphore to get down",
        "correct": true
      }
    ]
  },
  {
    "question": "the hardware mechanisms necessary for paging are (\"frame error\" also called \"page fault\", \"frame miss\"):",
    "answers": [
      {
        "text": "address translation, page index tables, \"frame error\" interrupt, associative memory, page swapper",
        "correct": false
      },
      {
        "text": "address translation, page index tables, page reference bits, \"frame error\" interrupt",
        "correct": false
      },
      {
        "text": "address translation, page index tables, page reference bits, \"frame error\" interrupt, associative memory",
        "correct": false
      },
      {
        "text": "address translation, page index tables, \"frame error\" interrupt",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "loader",
        "correct": false
      },
      {
        "text": "linker",
        "correct": false
      },
      {
        "text": "compiler",
        "correct": false
      },
      {
        "text": "special registers (datum)",
        "correct": true
      }
    ]
  },
  {
    "question": "the hardware resources of a computer system are:",
    "answers": [
      {
        "text": "processor time",
        "correct": true
      },
      {
        "text": "primary memory",
        "correct": true
      },
      {
        "text": "peripheral devices",
        "correct": true
      },
      {
        "text": "windows on the screen",
        "correct": false
      }
    ]
  },
  {
    "question": "after accepting an interrupt, the next interrupts are:",
    "answers": [
      {
        "text": "partly blocked, partly unblocked, according to the level of the accepted interrupt",
        "correct": false
      },
      {
        "text": "some blocked, some unblocked, developer decides",
        "correct": false
      },
      {
        "text": "unblocked",
        "correct": false
      },
      {
        "text": "blocked",
        "correct": true
      }
    ]
  },
  {
    "question": "allocation unit for file storage:",
    "answers": [
      {
        "text": "may be a variable in a partition",
        "correct": false
      },
      {
        "text": "it should be selected to match the characteristics of the data",
        "correct": false
      },
      {
        "text": "must be constant across the disk partition",
        "correct": true
      },
      {
        "text": "may differ between files on a partition",
        "correct": false
      }
    ]
  },
  {
    "question": "in a concurrent environment, the operating system decides which task the cpu gets, when, and for how long. this feature is called:",
    "answers": [
      {
        "text": "task management",
        "correct": false
      },
      {
        "text": "task timetable planning",
        "correct": false
      },
      {
        "text": "traffic management",
        "correct": false
      },
      {
        "text": "task scheduling",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is used to desynchronize processes with different relative speeds?",
    "answers": [
      {
        "text": "interrupts",
        "correct": false
      },
      {
        "text": "preempting",
        "correct": false
      },
      {
        "text": "scheduling",
        "correct": false
      },
      {
        "text": "buffer",
        "correct": true
      }
    ]
  },
  {
    "question": "compaction solves the problem:",
    "answers": [
      {
        "text": "internal fragmentation",
        "correct": false
      },
      {
        "text": "external fragmentation",
        "correct": true
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "page fault",
        "correct": false
      }
    ]
  },
  {
    "question": "scheduler function is:",
    "answers": [
      {
        "text": "scheduling tasks on the processor",
        "correct": false
      },
      {
        "text": "selecting a task to run",
        "correct": true
      },
      {
        "text": "counting the cpu time used by tasks",
        "correct": false
      },
      {
        "text": "changing task priorities",
        "correct": false
      }
    ]
  },
  {
    "question": "what does the file system layer do?",
    "answers": [
      {
        "text": "tracks the status of information",
        "correct": true
      },
      {
        "text": "manages files",
        "correct": true
      },
      {
        "text": "manages remote file systems",
        "correct": false
      },
      {
        "text": "manages remote files",
        "correct": false
      }
    ]
  },
  {
    "question": "the file system layer plays the following role in the operating system:",
    "answers": [
      {
        "text": "it runs programs stored in files",
        "correct": false
      },
      {
        "text": "performs file opening and closing operations",
        "correct": true
      },
      {
        "text": "it performs directory services in the hierarchy of disk files",
        "correct": true
      },
      {
        "text": "controls file access rights",
        "correct": true
      }
    ]
  },
  {
    "question": "the resources of the computer system are:",
    "answers": [
      {
        "text": "user programs",
        "correct": false
      },
      {
        "text": "primary memory",
        "correct": true
      },
      {
        "text": "peripheral devices",
        "correct": true
      },
      {
        "text": "processor time",
        "correct": true
      }
    ]
  },
  {
    "question": "paging is in thrashing if:",
    "answers": [
      {
        "text": "the system spends less time paging than execution",
        "correct": false
      },
      {
        "text": "page cannot be swapped",
        "correct": false
      },
      {
        "text": "page faults occur",
        "correct": false
      },
      {
        "text": "the system spends more time paging than execution",
        "correct": true
      }
    ]
  },
  {
    "question": "paging is in thrashing if:",
    "answers": [
      {
        "text": "the system spends less time paging than execution",
        "correct": false
      },
      {
        "text": "page cannot be swapped",
        "correct": false
      },
      {
        "text": "page faults occur",
        "correct": false
      },
      {
        "text": "the system spends more time paging than execution",
        "correct": true
      }
    ]
  },
  {
    "question": "in a multitasking environment, the operating system decides which task the cpu gets, when, and for how long. this feature is called:",
    "answers": [
      {
        "text": "task management",
        "correct": false
      },
      {
        "text": "traffic control",
        "correct": false
      },
      {
        "text": "task timetable management",
        "correct": false
      },
      {
        "text": "task scheduling",
        "correct": true
      }
    ]
  },
  {
    "question": "which of the following are affected by the thrashing phenomenon?",
    "answers": [
      {
        "text": "program size",
        "correct": false
      },
      {
        "text": "program structure",
        "correct": false
      },
      {
        "text": "mass memory",
        "correct": false
      },
      {
        "text": "primary memory",
        "correct": true
      }
    ]
  },
  {
    "question": "is memory protection useless in a non-concurrent system?",
    "answers": [
      {
        "text": "prawda",
        "correct": false
      },
      {
        "text": "fałsz",
        "correct": true
      }
    ]
  },
  {
    "question": "the program must be specially compiled to run in paged memory.",
    "answers": [
      {
        "text": "prawda",
        "correct": false
      },
      {
        "text": "fałsz",
        "correct": true
      }
    ]
  },
  {
    "question": "the effective address is at the same time:",
    "answers": [
      {
        "text": "relative address",
        "correct": false
      },
      {
        "text": "logical address",
        "correct": true
      },
      {
        "text": "indirect address",
        "correct": false
      },
      {
        "text": "physical address",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following memory allocation schemes can cause external fragmentation?",
    "answers": [
      {
        "text": "multiple contiguous fixed partitions of various sizes",
        "correct": true
      },
      {
        "text": "multiple contiguous fixed partitions of equal size",
        "correct": false
      },
      {
        "text": "segmentation",
        "correct": true
      },
      {
        "text": "sweeping",
        "correct": true
      }
    ]
  },
  {
    "question": "when starting a program, how is control passed to it from the operating system?",
    "answers": [
      {
        "text": "return from interrupt handler iret",
        "correct": true
      },
      {
        "text": "extracode",
        "correct": false
      },
      {
        "text": "jump",
        "correct": false
      },
      {
        "text": "jump with trace",
        "correct": false
      }
    ]
  },
  {
    "question": "what does the kernel do when there is no task (process) to run?",
    "answers": [
      {
        "text": "switches off the power supply",
        "correct": false
      },
      {
        "text": "executes an infinite loop in the kernel until a task arrives",
        "correct": false
      },
      {
        "text": "resets the entire system",
        "correct": false
      },
      {
        "text": "starts the idle task",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is part of time-sharing systems?",
    "answers": [
      {
        "text": "high-level scheduler",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "medium-level scheduler",
        "correct": false
      },
      {
        "text": "low-level scheduler",
        "correct": true
      }
    ]
  },
  {
    "question": "the following situations trigger 'error' exceptions:",
    "answers": [
      {
        "text": "extracode",
        "correct": false
      },
      {
        "text": "attempting to execute in user mode an instruction that is only legal in system mode",
        "correct": true
      },
      {
        "text": "attempting to execute an illegal instruction",
        "correct": true
      },
      {
        "text": "page fault (also known as frame fault, frame error, page miss)",
        "correct": false
      }
    ]
  },
  {
    "question": "the test-and-set or compare-and-swap instruction has the following characteristics:",
    "answers": [
      {
        "text": "it is possible to use only in 1-processor systems",
        "correct": false
      },
      {
        "text": "it is possible to use only on computers with common memory",
        "correct": true
      },
      {
        "text": "it is possible to deadlock with tas/cas operations on multiple variables",
        "correct": true
      },
      {
        "text": "requires active waiting from tasks",
        "correct": true
      }
    ]
  },
  {
    "question": "the following paging exceptions allow for returning to the program after they occur:",
    "answers": [
      {
        "text": "page fault",
        "correct": true
      },
      {
        "text": "attempt to read from the frame storing the code",
        "correct": false
      },
      {
        "text": "attempting to write to a write-protected frame",
        "correct": false
      },
      {
        "text": "interrupt on write (iow)",
        "correct": true
      }
    ]
  },
  {
    "question": "a memory management technique in which the system divides memory into equal-sized chunks with virtual base addresses divisible by a chunk size, to easily manage relocation, is called:",
    "answers": [
      {
        "text": "mapping",
        "correct": false
      },
      {
        "text": "fragmentation",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "paging",
        "correct": true
      }
    ]
  },
  {
    "question": "the multi-level interrupt controller includes:",
    "answers": [
      {
        "text": "the register of interrupt being serviced",
        "correct": false
      },
      {
        "text": "priority encoder",
        "correct": true
      },
      {
        "text": "collective interrupt mask",
        "correct": true
      },
      {
        "text": "individual interrupt mask",
        "correct": true
      }
    ]
  },
  {
    "question": "the interrupt acceptance sequence consists of (in the sequence):",
    "answers": [
      {
        "text": "identification of the interrupt level, saving the interrupt vector, performing a jump with a trace according to the interrupt table",
        "correct": true
      },
      {
        "text": "identification of the interrupt level, performing a jump with the trace according to the interrupt table, saving the interrupt vector",
        "correct": false
      },
      {
        "text": "identification of the interrupt level, performing a jump according to the interrupt table, saving the interrupt vector",
        "correct": false
      },
      {
        "text": "identification of the interrupt level, saving the interrupt vector, performing a jump according to the interrupt table",
        "correct": false
      }
    ]
  },
  {
    "question": "threads in operating system:",
    "answers": [
      {
        "text": "they share context except registers and stack",
        "correct": true
      },
      {
        "text": "they share the entire context",
        "correct": false
      },
      {
        "text": "they share context except stack",
        "correct": false
      }
    ]
  },
  {
    "question": "how is exception identification performed?",
    "answers": [
      {
        "text": "the specification of hardware interrupts is given over the data bus",
        "correct": true
      },
      {
        "text": "all exceptions are specified using the data bus",
        "correct": false
      },
      {
        "text": "the specification of hardware interrupts and traps is given over the data bus",
        "correct": false
      },
      {
        "text": "the specification of hardware interrupts and errors is given over the data bus",
        "correct": false
      }
    ]
  },
  {
    "question": "sjf selects the task:",
    "answers": [
      {
        "text": "which was last placed in the queue",
        "correct": false
      },
      {
        "text": "who waited the longest in the queue",
        "correct": false
      },
      {
        "text": "with the least cpu requirement",
        "correct": true
      },
      {
        "text": "which was first placed in the queue",
        "correct": false
      }
    ]
  },
  {
    "question": "virtual memory consists of:",
    "answers": [
      {
        "text": "primary memory and cloud storage",
        "correct": false
      },
      {
        "text": "primary and mass memory",
        "correct": true
      },
      {
        "text": "primary memory and cache",
        "correct": false
      },
      {
        "text": "cache memory and mass storage",
        "correct": false
      }
    ]
  },
  {
    "question": "context switch is:",
    "answers": [
      {
        "text": "writing registers to the task stack and retrieving them from another task stack",
        "correct": true
      },
      {
        "text": "switching to the system stack",
        "correct": false
      },
      {
        "text": "calling the kernel of the operating system",
        "correct": false
      },
      {
        "text": "extracode execution",
        "correct": false
      }
    ]
  },
  {
    "question": "having two-level page index tables:",
    "answers": [
      {
        "text": "the content of a level i table element is an index in a level ii table",
        "correct": false
      },
      {
        "text": "the content of a level i table element points to a level ii table",
        "correct": true
      },
      {
        "text": "the content of the level i table element is concatenated (combined) with the content of the level ii table element",
        "correct": false
      },
      {
        "text": "the content of a level i table element is added to the content of a level ii table element",
        "correct": false
      }
    ]
  },
  {
    "question": "mmu uses index tables to:",
    "answers": [
      {
        "text": "generate a relative address",
        "correct": false
      },
      {
        "text": "generating a physical address",
        "correct": true
      },
      {
        "text": "generate a logical address",
        "correct": false
      },
      {
        "text": "generate an effective address",
        "correct": false
      }
    ]
  },
  {
    "question": "the algorithm in which the most recently loaded page is swapped out is called (enter the abbreviation if applicable):",
    "answers": [
      {
        "text": "mru",
        "correct": false
      },
      {
        "text": "fifo",
        "correct": true
      }
    ]
  },
  {
    "question": "the purpose of mutual exclusion is:",
    "answers": [
      {
        "text": "deadlock prevention",
        "correct": false
      },
      {
        "text": "obtaining exclusive access",
        "correct": true
      },
      {
        "text": "secure context switch",
        "correct": false
      },
      {
        "text": "interrupt service",
        "correct": false
      }
    ]
  },
  {
    "question": "in unix, access rights are specified:",
    "answers": [
      {
        "text": "at the same time, for all files in a given directory owned by the user",
        "correct": false
      },
      {
        "text": "separately for write, read and execute/search",
        "correct": true
      },
      {
        "text": "individually for each file",
        "correct": true
      },
      {
        "text": "separately for the user, the group to which the user belongs and for all others",
        "correct": true
      }
    ]
  },
  {
    "question": "which of the following statements is true for system level threads?",
    "answers": [
      {
        "text": "multithreaded applications cannot use multiprocessing.",
        "correct": false
      },
      {
        "text": "the threading implementation at the kernel level is done by the thread library attached to the program.",
        "correct": false
      },
      {
        "text": "kernel-level threads require their descriptors in the kernel.",
        "correct": true
      },
      {
        "text": "user-level threads can be synchronized by the kernel.",
        "correct": false
      }
    ]
  },
  {
    "question": "allocation unit for file storage:",
    "answers": [
      {
        "text": "must be constant across the disk partition",
        "correct": true
      },
      {
        "text": "may differ between files in a partition",
        "correct": false
      },
      {
        "text": "may vary between partitions",
        "correct": true
      },
      {
        "text": "is any integer multiple of a sector (>0)",
        "correct": false
      }
    ]
  },
  {
    "question": "in which swapping algorithms is the m bit value used?",
    "answers": [
      {
        "text": "optimal",
        "correct": false
      },
      {
        "text": "lfu",
        "correct": false
      },
      {
        "text": "lru",
        "correct": false
      },
      {
        "text": "second chance",
        "correct": false
      },
      {
        "text": "working set",
        "correct": false
      },
      {
        "text": "clock",
        "correct": false
      },
      {
        "text": "no algorithm",
        "correct": false
      },
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "nru",
        "correct": true
      }
    ]
  },
  {
    "question": "the sequence of actions in interrupt handling:",
    "answers": [
      {
        "text": "saving a copy of the interrupt vector (pc and sr)",
        "correct": true
      },
      {
        "text": "switching to system mode (modification of pc and status register)",
        "correct": true
      },
      {
        "text": "programmatic context saving",
        "correct": true
      },
      {
        "text": "switching to the system stack",
        "correct": true
      }
    ]
  },
  {
    "question": "the kernel (microkernel) is responsible for:",
    "answers": [
      {
        "text": "interrupt handling (at the elementary level, then they are passed on to other layers).",
        "correct": true
      },
      {
        "text": "task control",
        "correct": true
      },
      {
        "text": "synchronization of processes and devices with processes",
        "correct": true
      },
      {
        "text": "memory allocation and freeing",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following memory allocation schemes causes external fragmentation?",
    "answers": [
      {
        "text": "multiple contiguous fixed partitions of equal size",
        "correct": false
      },
      {
        "text": "segmentation",
        "correct": true
      },
      {
        "text": "paging",
        "correct": false
      },
      {
        "text": "multiple contiguous fixed partitions of various sizes",
        "correct": true
      }
    ]
  },
  {
    "question": "static relocation is performed by:",
    "answers": [
      {
        "text": "special registers (datum)",
        "correct": false
      },
      {
        "text": "segment descriptors",
        "correct": false
      },
      {
        "text": "loader",
        "correct": true
      },
      {
        "text": "compiler",
        "correct": true
      }
    ]
  },
  {
    "question": "the scheduling goal, which is to occupy processors as efficiently as possible, is:",
    "answers": [
      {
        "text": "response time",
        "correct": false
      },
      {
        "text": "throughput",
        "correct": false
      },
      {
        "text": "utilization",
        "correct": true
      }
    ]
  },
  {
    "question": "individual interrupt mask:",
    "answers": [
      {
        "text": "a combinational circuit that calculates the number of the interrupt received",
        "correct": false
      },
      {
        "text": "a register whose bits are anded (conjunction) with the bits from the interrupt request register",
        "correct": true
      },
      {
        "text": "a register whose bits are ored (alternative) with the bits from the interrupt request register",
        "correct": false
      },
      {
        "text": "register in which addresses of devices reporting individual interrupts are stored",
        "correct": false
      }
    ]
  },
  {
    "question": "which swapping algorithms use page reference history?",
    "answers": [
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "nru",
        "correct": true
      },
      {
        "text": "lfu",
        "correct": true
      },
      {
        "text": "working set",
        "correct": false
      },
      {
        "text": "lru",
        "correct": true
      },
      {
        "text": "second chance",
        "correct": false
      },
      {
        "text": "working set clock",
        "correct": false
      }
    ]
  },
  {
    "question": "when the processor is released, the scheduler selects one of the queued processes:",
    "answers": [
      {
        "text": "waiting",
        "correct": false
      },
      {
        "text": "ready",
        "correct": true
      },
      {
        "text": "running",
        "correct": false
      },
      {
        "text": "suspended",
        "correct": false
      }
    ]
  },
  {
    "question": "on unix, the number of files is directly limited by:",
    "answers": [
      {
        "text": "the size of the space allocated for files",
        "correct": false
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "i-node table size",
        "correct": true
      },
      {
        "text": "allocation unit size",
        "correct": false
      }
    ]
  },
  {
    "question": "page thrashing is a phenomenon involving:",
    "answers": [
      {
        "text": "loading the same page over and over again",
        "correct": false
      },
      {
        "text": "frequent context changes that require page index tables to be reloaded to mmu cache",
        "correct": false
      },
      {
        "text": "frequently changing the values of bits describing pages in frames",
        "correct": false
      },
      {
        "text": "frequent loading of pages that have just been ejected from memory",
        "correct": true
      }
    ]
  },
  {
    "question": "the hardware resources of a computer system are:",
    "answers": [
      {
        "text": "primary memory",
        "correct": true
      },
      {
        "text": "processor time",
        "correct": true
      },
      {
        "text": "peripheral devices",
        "correct": true
      },
      {
        "text": "windows on the screen",
        "correct": false
      }
    ]
  },
  {
    "question": "the process context includes:",
    "answers": [
      {
        "text": "external device registers",
        "correct": false
      },
      {
        "text": "process descriptor",
        "correct": true
      },
      {
        "text": "code and data",
        "correct": true
      },
      {
        "text": "general purpose registers",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "segment descriptors",
        "correct": true
      },
      {
        "text": "compiler",
        "correct": false
      },
      {
        "text": "loader",
        "correct": false
      },
      {
        "text": "linker",
        "correct": false
      }
    ]
  },
  {
    "question": "address translation aims to:",
    "answers": [
      {
        "text": "generating a \"frame error\" interrupt when the page is out of memory",
        "correct": false
      },
      {
        "text": "converting a physical address to a virtual one",
        "correct": false
      },
      {
        "text": "converting a virtual address to a physical one",
        "correct": true
      },
      {
        "text": "detecting the phenomenon of locality of references",
        "correct": false
      }
    ]
  },
  {
    "question": "what type of code can execute on multiple datasets in parallel:",
    "answers": [
      {
        "text": "dynamically relocated",
        "correct": false
      },
      {
        "text": "reentrant",
        "correct": true
      },
      {
        "text": "binary",
        "correct": false
      }
    ]
  },
  {
    "question": "the resources of the computer system are:",
    "answers": [
      {
        "text": "processor time",
        "correct": true
      },
      {
        "text": "primary memory",
        "correct": true
      },
      {
        "text": "peripheral devices",
        "correct": true
      },
      {
        "text": "user programs",
        "correct": false
      }
    ]
  },
  {
    "question": "the combination of paging and segmentation consists in:",
    "answers": [
      {
        "text": "generating a \"frame error\" interrupt when the frame containing the page does not belong to the current segment",
        "correct": false
      },
      {
        "text": "identifying segments with pages",
        "correct": false
      },
      {
        "text": "the use of a segment table or a pool of segment registers treated as an additional, superior level of paging",
        "correct": true
      },
      {
        "text": "dividing pages into segments",
        "correct": false
      }
    ]
  },
  {
    "question": "when a suspended program is moved to auxiliary memory, its process state is called:",
    "answers": [
      {
        "text": "swept away",
        "correct": false
      },
      {
        "text": "moved out",
        "correct": false
      },
      {
        "text": "exchanged",
        "correct": false
      },
      {
        "text": "swept away",
        "correct": true
      }
    ]
  },
  {
    "question": "in fat-based systems, an allocation table item can have the following values:",
    "answers": [
      {
        "text": "free",
        "correct": true
      },
      {
        "text": "locked for exclusive access",
        "correct": false
      },
      {
        "text": "busy and not last in the chain",
        "correct": true
      },
      {
        "text": "occupied and last in the chain",
        "correct": true
      },
      {
        "text": "damaged",
        "correct": true
      }
    ]
  },
  {
    "question": "which scheduler is also called a job planner?",
    "answers": [
      {
        "text": "auxiliary",
        "correct": false
      },
      {
        "text": "long-term",
        "correct": true
      },
      {
        "text": "medium-term",
        "correct": false
      },
      {
        "text": "short-term",
        "correct": false
      }
    ]
  },
  {
    "question": "a program compiled to be executed in contiguous memory can be executed in paged memory.",
    "answers": [
      {
        "text": "true",
        "correct": true
      },
      {
        "text": "false",
        "correct": false
      }
    ]
  },
  {
    "question": "in what states can a task occur?",
    "answers": [
      {
        "text": "ready",
        "correct": true
      },
      {
        "text": "resetted",
        "correct": false
      },
      {
        "text": "current",
        "correct": true
      },
      {
        "text": "blocked",
        "correct": true
      }
    ]
  },
  {
    "question": "internal fragmentation can be removed by:",
    "answers": [
      {
        "text": "movement of allocated blocks in memory",
        "correct": false
      },
      {
        "text": "transferring allocated memory blocks to disk",
        "correct": false
      },
      {
        "text": "the use of the \"onion\" algorithm",
        "correct": false
      },
      {
        "text": "allocating unused portions of memory within blocks to other programs",
        "correct": false
      },
      {
        "text": "no response from the others",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "linker",
        "correct": false
      },
      {
        "text": "loader",
        "correct": false
      },
      {
        "text": "special registers (datum)",
        "correct": true
      },
      {
        "text": "paging system",
        "correct": true
      }
    ]
  },
  {
    "question": "discontinuous allocation:",
    "answers": [
      {
        "text": "increases external fragmentation",
        "correct": true
      },
      {
        "text": "increases internal fragmentation",
        "correct": false
      },
      {
        "text": "reduces internal fragmentation",
        "correct": false
      },
      {
        "text": "reduces external fragmentation",
        "correct": false
      }
    ]
  },
  {
    "question": "the system stack must provide space for:",
    "answers": [
      {
        "text": "cpu registers",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines and possible software interrupts",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines +1",
        "correct": true
      },
      {
        "text": "processor registers in as many copies as there are devices in the system +1",
        "correct": false
      }
    ]
  },
  {
    "question": "a single-program system is one that, in principle:",
    "answers": [
      {
        "text": "allows for storing only one program in mass memory",
        "correct": false
      },
      {
        "text": "runs on a uniprocessor computer",
        "correct": true
      },
      {
        "text": "allows for storing only one program in primary memory",
        "correct": true
      },
      {
        "text": "needs relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "a typical collection of program segments includes (come of them can be combined):",
    "answers": [
      {
        "text": "stack segment",
        "correct": true
      },
      {
        "text": "data segment",
        "correct": true
      },
      {
        "text": "processor registers segment",
        "correct": false
      },
      {
        "text": "page index tables segment",
        "correct": false
      },
      {
        "text": "code segment",
        "correct": true
      }
    ]
  },
  {
    "question": "general semaphore:",
    "answers": [
      {
        "text": "requires busy waiting",
        "correct": false
      },
      {
        "text": "is to perform only indvisible operations",
        "correct": true
      },
      {
        "text": "is a shared variable",
        "correct": true
      },
      {
        "text": "can be only non-negative",
        "correct": true
      }
    ]
  },
  {
    "question": "what can happen when a job leaves the critical section and more than 1 task is waiting for the critical section?",
    "answers": [
      {
        "text": "letting both tasks into the critical section",
        "correct": false
      },
      {
        "text": "deadlock waiting for critical section",
        "correct": false
      },
      {
        "text": "starvation awaiting a critical section",
        "correct": true
      },
      {
        "text": "active waiting for a critical section",
        "correct": false
      }
    ]
  },
  {
    "question": "in what states can a task occur?",
    "answers": [
      {
        "text": "ready",
        "correct": true
      },
      {
        "text": "resetted",
        "correct": false
      },
      {
        "text": "current",
        "correct": true
      },
      {
        "text": "blocked",
        "correct": true
      }
    ]
  },
  {
    "question": "internal fragmentation can be removed by:",
    "answers": [
      {
        "text": "movement of allocated blocks in memory",
        "correct": false
      },
      {
        "text": "transferring allocated memory blocks to disk",
        "correct": false
      },
      {
        "text": "the use of the \"onion\" algorithm",
        "correct": false
      },
      {
        "text": "allocating unused portions of memory within blocks to other programs",
        "correct": false
      },
      {
        "text": "no response from the others",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "linker",
        "correct": true
      },
      {
        "text": "loader",
        "correct": false
      },
      {
        "text": "special registers (datum)",
        "correct": false
      },
      {
        "text": "paging system",
        "correct": false
      }
    ]
  },
  {
    "question": "discontinuous allocation:",
    "answers": [
      {
        "text": "increases external fragmentation",
        "correct": true
      },
      {
        "text": "increases internal fragmentation",
        "correct": false
      },
      {
        "text": "reduces internal fragmentation",
        "correct": false
      },
      {
        "text": "reduces external fragmentation",
        "correct": false
      }
    ]
  },
  {
    "question": "the system stack must provide space for:",
    "answers": [
      {
        "text": "cpu registers",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines and possible software interrupts",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines +1",
        "correct": true
      },
      {
        "text": "processor registers in as many copies as there are devices in the system +1",
        "correct": false
      }
    ]
  },
  {
    "question": "a single-program system is one that, in principle:",
    "answers": [
      {
        "text": "allows for storing only one program in mass memory",
        "correct": false
      },
      {
        "text": "runs on a uniprocessor computer",
        "correct": true
      },
      {
        "text": "allows for storing only one program in primary memory",
        "correct": true
      },
      {
        "text": "needs relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "a typical collection of program segments includes (come of them can be combined):",
    "answers": [
      {
        "text": "stack segment",
        "correct": true
      },
      {
        "text": "data segment",
        "correct": true
      },
      {
        "text": "processor registers segment",
        "correct": false
      },
      {
        "text": "page index tables segment",
        "correct": false
      },
      {
        "text": "code segment",
        "correct": true
      }
    ]
  },
  {
    "question": "general semaphore:",
    "answers": [
      {
        "text": "requires busy waiting",
        "correct": false
      },
      {
        "text": "is to perform only indvisible operations",
        "correct": true
      },
      {
        "text": "is a shared variable",
        "correct": true
      },
      {
        "text": "can be only non-negative",
        "correct": true
      }
    ]
  },
  {
    "question": "what can happen when a job leaves the critical section and more than 1 task is waiting for the critical section?",
    "answers": [
      {
        "text": "letting both tasks into the critical section",
        "correct": false
      },
      {
        "text": "deadlock waiting for critical section",
        "correct": false
      },
      {
        "text": "starvation awaiting a critical section",
        "correct": true
      },
      {
        "text": "active waiting for a critical section",
        "correct": false
      }
    ]
  },
  {
    "question": "in what form is the data placed in raid 4 across data disks?",
    "answers": [
      {
        "text": "frame number",
        "correct": false
      },
      {
        "text": "the frame number concatenated with the page number",
        "correct": false
      },
      {
        "text": "the page number concatenated with the frame number",
        "correct": false
      },
      {
        "text": "page number",
        "correct": true
      }
    ]
  },
  {
    "question": "static relocation is performed by:",
    "answers": [
      {
        "text": "segment descriptors",
        "correct": false
      },
      {
        "text": "linker",
        "correct": true
      },
      {
        "text": "special registers (datum)",
        "correct": false
      },
      {
        "text": "paging system",
        "correct": false
      }
    ]
  },
  {
    "question": "round-robin scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "time-sharing system",
        "correct": true
      },
      {
        "text": "system with different classes of tasks",
        "correct": false
      },
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": false
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm? the system is equipped with 2 processors.",
    "answers": [
      {
        "text": "4.4",
        "correct": true
      }
    ]
  },
  {
    "question": "after replacing a corrupted disk in raid 4, what values should be put in the strip on disk 3? (assuming parity bit keeps corresponding strip bits 0-3 odd.)",
    "answers": [
      {
        "text": "11001",
        "correct": false
      },
      {
        "text": "1 1 0 0 1",
        "correct": true
      }
    ]
  },
  {
    "question": "assuming memory cells are 1-byte, what is the maximum size of the program in kb if the page number in the address field is 10 bits, the offset is 11 bits, and the frame number is 12 bits? all entries in the tis page index table are on a 4-byte word boundary.",
    "answers": [
      {
        "text": "4",
        "correct": true
      }
    ]
  },
  {
    "question": "what is the average time in the system for tasks in the batch, using sjf algorithm?",
    "answers": [
      {
        "text": "3.8",
        "correct": true
      }
    ]
  },
  {
    "question": "after replacing a corrupted disk in raid 4, what values should be put in the strip on disk 3? (assuming parity bit keeps corresponding strip bits 0-3 odd.)",
    "answers": [
      {
        "text": "10101",
        "correct": true
      }
    ]
  },
  {
    "question": "assuming memory cells are 1-byte, what is the maximum size of the program's virtual memory in mb if the page number in the address field is 11 bits, the offset is 12 bits, and the frame number is 12 bits? all entries in the tis page index table are on a 16-bit word boundary.",
    "answers": [
      {
        "text": "8",
        "correct": true
      }
    ]
  },
  {
    "question": "the mechanism for moving programs between primary memory and mass storage is called:",
    "answers": [
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "sweeping",
        "correct": true
      },
      {
        "text": "leaching",
        "correct": false
      }
    ]
  },
  {
    "question": "using test-and-set or compare-and-swap in synchronization:",
    "answers": [
      {
        "text": "it requires processes to actively wait",
        "correct": true
      },
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "it can only be applied in systems with shared memory",
        "correct": true
      },
      {
        "text": "stops the processor if 0 is read",
        "correct": false
      }
    ]
  },
  {
    "question": "the following situations cause the exceptions (processor internal interrupts) of the 'error' type:",
    "answers": [
      {
        "text": "memory reference beyond limit register value",
        "correct": true
      },
      {
        "text": "memory reference in the area of the page that is not in memory",
        "correct": true
      },
      {
        "text": "an attempt to write to the page for which the 'read only' bit is set",
        "correct": true
      },
      {
        "text": "a reference to memory that is not in the address space",
        "correct": true
      }
    ]
  },
  {
    "question": "a program compiled for execution in paged memory can be executed in regular memory.",
    "answers": [
      {
        "text": "true",
        "correct": false
      },
      {
        "text": "false",
        "correct": true
      }
    ]
  },
  {
    "question": "the conversion of the effective address to the physical one takes place:",
    "answers": [
      {
        "text": "in the bus arbiter",
        "correct": false
      },
      {
        "text": "in the arithmetic-logic unit",
        "correct": false
      },
      {
        "text": "in the memory management unit",
        "correct": true
      },
      {
        "text": "in the sequencer",
        "correct": false
      }
    ]
  },
  {
    "question": "in what states can a task occur?",
    "answers": [
      {
        "text": "resetted",
        "correct": false
      },
      {
        "text": "blocked",
        "correct": true
      },
      {
        "text": "ready",
        "correct": true
      },
      {
        "text": "current",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is used to desynchronize processes with different relative speeds?",
    "answers": [
      {
        "text": "preempting",
        "correct": false
      },
      {
        "text": "interrupts",
        "correct": false
      },
      {
        "text": "scheduling",
        "correct": true
      },
      {
        "text": "buffer",
        "correct": false
      }
    ]
  },
  {
    "question": "the environment in which the process is executed includes:",
    "answers": [
      {
        "text": "contents of the interrupt request register",
        "correct": false
      },
      {
        "text": "open files",
        "correct": true
      },
      {
        "text": "the content in the memory management unit",
        "correct": false
      },
      {
        "text": "general purpose registers content",
        "correct": true
      }
    ]
  },
  {
    "question": "for address translation, the following is used:",
    "answers": [
      {
        "text": "associative translation buffer",
        "correct": false
      },
      {
        "text": "translation register",
        "correct": false
      },
      {
        "text": "reference and protection bits",
        "correct": false
      },
      {
        "text": "index table",
        "correct": true
      }
    ]
  },
  {
    "question": "what is true about system level threads?",
    "answers": [
      {
        "text": "thread switching does not require interaction with the operating system.",
        "correct": false
      },
      {
        "text": "all threads of the process must execute on the same processor.",
        "correct": false
      },
      {
        "text": "all process threads can share the same set of open files.",
        "correct": true
      },
      {
        "text": "all process threads share the same address space.",
        "correct": true
      }
    ]
  },
  {
    "question": "in a four-level page index table, the page number is:",
    "answers": [
      {
        "text": "in the first level table - the leftmost in the figure",
        "correct": false
      },
      {
        "text": "in the table of the last level - the rightmost in the figure",
        "correct": false
      },
      {
        "text": "part in the table of each level",
        "correct": false
      },
      {
        "text": "none of the above answers",
        "correct": true
      }
    ]
  },
  {
    "question": "the page fault interrupt is used to:",
    "answers": [
      {
        "text": "detection of an attempt to write outside the address space of the frame",
        "correct": false
      },
      {
        "text": "whether the frame is empty or contains a page",
        "correct": false
      },
      {
        "text": "detection of an access attempt from a frame not allocated to the program",
        "correct": false
      },
      {
        "text": "downloads to the memory of the requested page",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "segment descriptors",
        "correct": false
      },
      {
        "text": "special registers (limit)",
        "correct": false
      },
      {
        "text": "compiler",
        "correct": false
      },
      {
        "text": "paging system",
        "correct": true
      }
    ]
  },
  {
    "question": "the program supervisor layer in the operating system has the following role:",
    "answers": [
      {
        "text": "intercepts all program system calls and routes them to the appropriate layers",
        "correct": true
      },
      {
        "text": "runs programs",
        "correct": true
      },
      {
        "text": "deals with buffering data written and read from mass memory",
        "correct": false
      },
      {
        "text": "deals with the management of primary memory (memory allocation to programs)",
        "correct": true
      }
    ]
  },
  {
    "question": "what does the file system layer do?",
    "answers": [
      {
        "text": "tracks the status of information",
        "correct": true
      },
      {
        "text": "manages files",
        "correct": true
      },
      {
        "text": "manages remote file systems",
        "correct": false
      },
      {
        "text": "manages remote files",
        "correct": false
      }
    ]
  },
  {
    "question": "if the loader inserts a program with absolute addresses into a fixed address space, it is called:",
    "answers": [
      {
        "text": "static loading",
        "correct": false
      },
      {
        "text": "dynamic loading",
        "correct": false
      },
      {
        "text": "dynamic relocation",
        "correct": true
      },
      {
        "text": "static relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "which task queue can never be empty?",
    "answers": [
      {
        "text": "running tasks",
        "correct": true
      },
      {
        "text": "swept away tasks",
        "correct": false
      },
      {
        "text": "suspended tasks",
        "correct": false
      },
      {
        "text": "ready tasks",
        "correct": false
      }
    ]
  },
  {
    "question": "a multiprogram system is one that, in principle:",
    "answers": [
      {
        "text": "it allows for storing many programs in the main memory",
        "correct": true
      },
      {
        "text": "allows for running programs only one after another",
        "correct": false
      },
      {
        "text": "allows for storing multiple programs in mass memory",
        "correct": false
      },
      {
        "text": "allows for running more than one program at the same time",
        "correct": false
      }
    ]
  },
  {
    "question": "processor access scheduling decisions may be made under which of the following circumstances?",
    "answers": [
      {
        "text": "when a task transitions from the active state to the ready state",
        "correct": true
      },
      {
        "text": "when a task goes from the waiting state to the ready state",
        "correct": true
      },
      {
        "text": "when a task goes from the active state to the waiting state",
        "correct": true
      },
      {
        "text": "when a task terminates",
        "correct": true
      }
    ]
  },
  {
    "question": "what does the file system layer do?",
    "answers": [
      {
        "text": "manages remote files",
        "correct": false
      },
      {
        "text": "manages remote file systems",
        "correct": false
      },
      {
        "text": "keeps track of how information is recorded",
        "correct": true
      },
      {
        "text": "tracks the location of the data",
        "correct": true
      }
    ]
  },
  {
    "question": "having two-level page index tables:",
    "answers": [
      {
        "text": "the content of a level i table element is an index in a level ii table",
        "correct": false
      },
      {
        "text": "the content of a level i table element points to a level ii table",
        "correct": true
      },
      {
        "text": "the content of the level i table element is concatenated (combined) with the content of the level ii table element",
        "correct": false
      },
      {
        "text": "the content of a level i table element is added to the content of a level ii table element",
        "correct": false
      }
    ]
  },
  {
    "question": "the kernel is ___ user-level threads.",
    "answers": [
      {
        "text": "part",
        "correct": false
      },
      {
        "text": "creator",
        "correct": false
      },
      {
        "text": "aware",
        "correct": false
      },
      {
        "text": "unaware",
        "correct": true
      }
    ]
  },
  {
    "question": "in a fat-based disk system, file size is directly limited by:",
    "answers": [
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": true
      },
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "the size of the disk space",
        "correct": true
      },
      {
        "text": "fat table size",
        "correct": false
      }
    ]
  },
  {
    "question": "what does the kernel do when there is no task (process) to run?",
    "answers": [
      {
        "text": "resets the entire system",
        "correct": false
      },
      {
        "text": "starts the idle task",
        "correct": true
      },
      {
        "text": "executes an infinite loop in the kernel until a task arrives",
        "correct": false
      },
      {
        "text": "switches off the power supply",
        "correct": false
      }
    ]
  },
  {
    "question": "context switch is:",
    "answers": [
      {
        "text": "writing registers to the task stack and retrieving them from another task stack",
        "correct": true
      },
      {
        "text": "extracode execution",
        "correct": false
      },
      {
        "text": "switching to the system stack",
        "correct": false
      },
      {
        "text": "calling the kernel of the operating system",
        "correct": false
      }
    ]
  },
  {
    "question": "between fork and exec operations, the following operations are performed:",
    "answers": [
      {
        "text": "opening the appropriate input/output files",
        "correct": true
      },
      {
        "text": "loading the program to be started into memory",
        "correct": true
      },
      {
        "text": "allocating the appropriate amount of memory for the program being started",
        "correct": false
      }
    ]
  },
  {
    "question": "in which swapping algorithms is it necessary to collectively clear the m-bits?",
    "answers": [
      {
        "text": "working set",
        "correct": false
      },
      {
        "text": "lfu",
        "correct": false
      },
      {
        "text": "working set clock",
        "correct": false
      },
      {
        "text": "lru",
        "correct": false
      },
      {
        "text": "second chance",
        "correct": false
      },
      {
        "text": "clock",
        "correct": false
      },
      {
        "text": "no algorithm",
        "correct": true
      },
      {
        "text": "nru",
        "correct": false
      },
      {
        "text": "fifo",
        "correct": false
      }
    ]
  },
  {
    "question": "the segment descriptor table contains:",
    "answers": [
      {
        "text": "address of the segment page index table of the top-level (first level) in the hierarchy",
        "correct": true
      },
      {
        "text": "address of the segment page index table of the bottom-level (last level) in the hierarchy",
        "correct": false
      },
      {
        "text": "addresses of all segment page index tables",
        "correct": false
      }
    ]
  },
  {
    "question": "during the interrupt handling:",
    "answers": [
      {
        "text": "other interrupts may or may not be accepted at the discretion of the programmer",
        "correct": true
      },
      {
        "text": "other interrupts can be accepted",
        "correct": false
      },
      {
        "text": "other interrupts are disabled",
        "correct": false
      }
    ]
  },
  {
    "question": "the content of the first (highest in the hierarchy) level of the page index table is:",
    "answers": [
      {
        "text": "pointer to next pit",
        "correct": false
      },
      {
        "text": "second level pit address",
        "correct": true
      }
    ]
  },
  {
    "question": "virtual memory consists of:",
    "answers": [
      {
        "text": "cache memory and mass storage",
        "correct": false
      },
      {
        "text": "primary and mass memory",
        "correct": true
      },
      {
        "text": "primary memory and cloud storage",
        "correct": false
      },
      {
        "text": "primary memory and cache",
        "correct": false
      }
    ]
  },
  {
    "question": "internal fragmentation can be removed by:",
    "answers": [
      {
        "text": "movement of allocated blocks in memory",
        "correct": false
      },
      {
        "text": "transferring allocated memory blocks to disk",
        "correct": false
      },
      {
        "text": "the use of the \"onion\" algorithm",
        "correct": false
      },
      {
        "text": "allocating unused portions of memory within blocks to other programs",
        "correct": false
      },
      {
        "text": "no response from the others",
        "correct": true
      }
    ]
  },
  {
    "question": "compaction solves the problem:",
    "answers": [
      {
        "text": "external fragmentation",
        "correct": true
      },
      {
        "text": "internal fragmentation",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "page fault",
        "correct": false
      }
    ]
  },
  {
    "question": "for address translation, the following is used:",
    "answers": [
      {
        "text": "reference and protection bits",
        "correct": false
      },
      {
        "text": "index table",
        "correct": true
      },
      {
        "text": "translation register",
        "correct": false
      },
      {
        "text": "associative translation buffer",
        "correct": true
      }
    ]
  },
  {
    "question": "the following situations cause \"error\" exceptions (processor internal interrupts)",
    "answers": [
      {
        "text": "instruction legal but prohibited in user mode",
        "correct": true
      },
      {
        "text": "extracode",
        "correct": false
      },
      {
        "text": "illegal instruction",
        "correct": true
      }
    ]
  },
  {
    "question": "conditional variables in a monitor",
    "answers": [
      {
        "text": "they guard access to the critical region of the monitor",
        "correct": false
      },
      {
        "text": "they are used to check whether the conditions for process continuation are met",
        "correct": false
      },
      {
        "text": "they are used to suspend processes that cannot run because the conditions for their continuation are not met",
        "correct": true
      }
    ]
  },
  {
    "question": "in a fat-based disk system (without sharing allocation units by files), the number of files is directly limited by:",
    "answers": [
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "fat table size",
        "correct": true
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      },
      {
        "text": "the size of the disk space",
        "correct": true
      }
    ]
  },
  {
    "question": "indulgent scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "system with many process classes",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": true
      },
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "time-sharing system",
        "correct": false
      }
    ]
  },
  {
    "question": "after accepting an interrupt, the next interrupts are:",
    "answers": [
      {
        "text": "some blocked, some unblocked, developer decides",
        "correct": false
      },
      {
        "text": "blocked",
        "correct": true
      },
      {
        "text": "partly blocked, partly unblocked, according to the level of the accepted interrupt",
        "correct": false
      },
      {
        "text": "unblocked",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is part of time-sharing systems?",
    "answers": [
      {
        "text": "high-level scheduler",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "low-level scheduler",
        "correct": true
      },
      {
        "text": "medium-level scheduler",
        "correct": false
      }
    ]
  },
  {
    "question": "round-robin scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "real-time system",
        "correct": false
      },
      {
        "text": "time-sharing system",
        "correct": true
      },
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "system with different classes of tasks",
        "correct": false
      }
    ]
  },
  {
    "question": "multiprogramming is a technique in which, as a rule:",
    "answers": [
      {
        "text": "is a method of allocating processor time",
        "correct": false
      },
      {
        "text": "many programs can be stored in primary memory",
        "correct": true
      },
      {
        "text": "only addresses that can be generated by the processor when performing calculations are used",
        "correct": false
      },
      {
        "text": "is a memory allocation method by which a program is divided into equal parts",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is part of batch systems?",
    "answers": [
      {
        "text": "medium-tevel scheduler",
        "correct": false
      },
      {
        "text": "low-level scheduler",
        "correct": false
      },
      {
        "text": "high-level scheduler",
        "correct": true
      },
      {
        "text": "no scheduler is needed",
        "correct": false
      }
    ]
  },
  {
    "question": "using the test-and-set instruction in synchronization:",
    "answers": [
      {
        "text": "stops the processor if 0 is read",
        "correct": false
      },
      {
        "text": "requires an explicit relinquishment of the processor to another process",
        "correct": false
      },
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "it requires processes to actively wait",
        "correct": true
      }
    ]
  },
  {
    "question": "the direct resume rule means that:",
    "answers": [
      {
        "text": "the resuming process loses the critical region",
        "correct": true
      },
      {
        "text": "the resuming process applies for the critical region just like other processes waiting to enter the critical region",
        "correct": true
      },
      {
        "text": "the resuming process gets a critical region after the resumed process exits the critical region",
        "correct": false
      }
    ]
  },
  {
    "question": "static relocation is performed by:",
    "answers": [
      {
        "text": "compiler",
        "correct": true
      },
      {
        "text": "segment descriptors",
        "correct": false
      },
      {
        "text": "linker",
        "correct": true
      },
      {
        "text": "paging system",
        "correct": false
      }
    ]
  },
  {
    "question": "consider the following sequence of address references: 123, 215, 600, 1234, 76, 96. if the page size is 100, the order of page references is as follows:",
    "answers": [
      {
        "text": "0,2,6,12,0,0",
        "correct": false
      },
      {
        "text": "1,2,6,12,0,0",
        "correct": false
      },
      {
        "text": "12,21,60,123,7,9",
        "correct": false
      },
      {
        "text": "1,2,6,12,0,0",
        "correct": true
      }
    ]
  },
  {
    "question": "the kernel (microkernel) is responsible for:",
    "answers": [
      {
        "text": "interrupt handling (at the elementary level, then they are passed on to other layers).",
        "correct": true
      },
      {
        "text": "synchronization of processes and devices with processes",
        "correct": true
      },
      {
        "text": "memory allocation and freeing",
        "correct": false
      },
      {
        "text": "task control",
        "correct": true
      }
    ]
  },
  {
    "question": "twice consecutive execution in one process of operation p on a raised binary semaphore:",
    "answers": [
      {
        "text": "causes the semaphore to get down",
        "correct": false
      },
      {
        "text": "if a semaphore guards a critical region, it leads to a deadlock",
        "correct": true
      },
      {
        "text": "it doesn't change anything",
        "correct": false
      },
      {
        "text": "decreases semaphore value by 2",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt vector:",
    "answers": [
      {
        "text": "contains minimal information that cannot be saved programmatically",
        "correct": true
      },
      {
        "text": "contains the instruction counter, condition bits, interrupt mask, and general purpose registers",
        "correct": false
      },
      {
        "text": "contains the id of the process that should be restarted",
        "correct": false
      },
      {
        "text": "it is saved automatically when an interrupt is accepted",
        "correct": true
      }
    ]
  },
  {
    "question": "which of the following interrupts a running process?",
    "answers": [
      {
        "text": "scheduler",
        "correct": false
      },
      {
        "text": "hardaware interrupt",
        "correct": true
      },
      {
        "text": "power fail interrupt",
        "correct": true
      },
      {
        "text": "timer interrupts",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "paging system",
        "correct": true
      },
      {
        "text": "segment descriptors",
        "correct": true
      },
      {
        "text": "special registers (datum)",
        "correct": true
      },
      {
        "text": "compiler",
        "correct": false
      }
    ]
  },
  {
    "question": "what does the file system layer do?",
    "answers": [
      {
        "text": "manages files",
        "correct": true
      },
      {
        "text": "manages remote file systems",
        "correct": false
      },
      {
        "text": "manages relationships between files",
        "correct": false
      },
      {
        "text": "manages remote files",
        "correct": false
      }
    ]
  },
  {
    "question": "what is a scheduler?",
    "answers": [
      {
        "text": "memory allocation procedure",
        "correct": false
      },
      {
        "text": "procedure that schedules frame release in the page replace algorithm",
        "correct": false
      },
      {
        "text": "the system process that allocates the processor",
        "correct": false
      },
      {
        "text": "a kernel routine that selects a task to execute",
        "correct": true
      }
    ]
  },
  {
    "question": "fragmentation is implied by:",
    "answers": [
      {
        "text": "external by freeing blocks in a deallocation order not reverse to allocation",
        "correct": true
      },
      {
        "text": "external by segmentation",
        "correct": false
      },
      {
        "text": "internal by partitioning into quantized blocks",
        "correct": true
      },
      {
        "text": "internal by paging",
        "correct": true
      },
      {
        "text": "external by resizing allocated blocks",
        "correct": true
      }
    ]
  },
  {
    "question": "onion algorithm:",
    "answers": [
      {
        "text": "causes external fragmentation",
        "correct": true
      },
      {
        "text": "reduces external fragmentation by aligning the allocation order with the process hierarchy",
        "correct": true
      },
      {
        "text": "causes internal fragmentation",
        "correct": true
      }
    ]
  },
  {
    "question": "the scheduling goal, which is to occupy processors as efficiently as possible, is:",
    "answers": [
      {
        "text": "response time",
        "correct": false
      },
      {
        "text": "productivity",
        "correct": false
      },
      {
        "text": "utilization",
        "correct": true
      }
    ]
  },
  {
    "question": "a program compiled to be executed in contiguous memory can be executed in paged memory.",
    "answers": [
      {
        "text": "true",
        "correct": true
      },
      {
        "text": "false",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt vector is saved in a case of:",
    "answers": [
      {
        "text": "accepting a hardware interrupt",
        "correct": true
      },
      {
        "text": "jump with trace",
        "correct": false
      },
      {
        "text": "accepting a non-maskable interrupt",
        "correct": true
      },
      {
        "text": "subroutine call",
        "correct": false
      }
    ]
  },
  {
    "question": "paging is in thrashing if:",
    "answers": [
      {
        "text": "the system spends less time paging than execution",
        "correct": false
      },
      {
        "text": "page faults occur",
        "correct": true
      },
      {
        "text": "the system spends more time paging than execution",
        "correct": true
      },
      {
        "text": "page cannot be swapped",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is part of batch systems?",
    "answers": [
      {
        "text": "medium-tevel scheduler",
        "correct": false
      },
      {
        "text": "no scheduler is needed",
        "correct": false
      },
      {
        "text": "high-level scheduler",
        "correct": true
      },
      {
        "text": "low-level scheduler",
        "correct": false
      }
    ]
  },
  {
    "question": "using the test-and-set instruction in synchronization:",
    "answers": [
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "stops the processor if 0 is read",
        "correct": false
      },
      {
        "text": "it requires processes to actively wait",
        "correct": true
      }
    ]
  },
  {
    "question": "is memory protection useless in a non-concurrent system?",
    "answers": [
      {
        "text": "true",
        "correct": false
      },
      {
        "text": "false",
        "correct": true
      }
    ]
  },
  {
    "question": "what is true for simultaneous execution in the same context?",
    "answers": [
      {
        "text": "the shared context forces threads to run on the same processor",
        "correct": false
      },
      {
        "text": "a multiprocessor kernel can be concurrent",
        "correct": true
      },
      {
        "text": "the use of threads ensures concurrency within the process.",
        "correct": true
      },
      {
        "text": "threads minimize context switch time.",
        "correct": true
      }
    ]
  },
  {
    "question": "allocation unit for storing files:",
    "answers": [
      {
        "text": "it should be selected to match the characteristics of the data",
        "correct": false
      },
      {
        "text": "must be constant across the disk partition",
        "correct": true
      },
      {
        "text": "may differ between files in a partition",
        "correct": false
      },
      {
        "text": "may vary between partitions",
        "correct": true
      }
    ]
  },
  {
    "question": "external fragmentation can be avoided by:",
    "answers": [
      {
        "text": "application of the onion algorithm",
        "correct": false
      },
      {
        "text": "allocation of fixed size static memory blocks",
        "correct": true
      },
      {
        "text": "freeing memory blocks in the reverse order to allocation",
        "correct": true
      },
      {
        "text": "freeing memory blocks in allocation order",
        "correct": false
      }
    ]
  },
  {
    "question": "in the four-level page index table, the frame number is:",
    "answers": [
      {
        "text": "none of the above answers",
        "correct": false
      },
      {
        "text": "in the first level table - the leftmost in the figure",
        "correct": false
      },
      {
        "text": "part in the table of each level",
        "correct": false
      },
      {
        "text": "in the table of the last level - the rightmost in the figure",
        "correct": true
      }
    ]
  },
  {
    "question": "when is the scheduler called?",
    "answers": [
      {
        "text": "at the end of the execution of each kernel procedure",
        "correct": true
      },
      {
        "text": "when the scheduler decides itself",
        "correct": false
      },
      {
        "text": "at the start of execution of each kernel procedure",
        "correct": false
      },
      {
        "text": "at the request of a user task",
        "correct": false
      }
    ]
  },
  {
    "question": "the key in associative memory is:",
    "answers": [
      {
        "text": "frame number",
        "correct": false
      },
      {
        "text": "the frame number concatenated with the page number",
        "correct": false
      },
      {
        "text": "the page number concatenated with the frame number",
        "correct": false
      },
      {
        "text": "page number",
        "correct": true
      }
    ]
  },
  {
    "question": "indulgent scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "time-sharing system",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": true
      },
      {
        "text": "system with many process classes",
        "correct": false
      },
      {
        "text": "every system",
        "correct": false
      }
    ]
  },
  {
    "question": "imprecise interrupts are:",
    "answers": [
      {
        "text": "unblocked in any state of the processor, not just between executions of instructions",
        "correct": false
      },
      {
        "text": "accepted in any state of the processor, not just between the execution of successive instructions",
        "correct": true
      },
      {
        "text": "issued in any state of the processor, not just between the execution of successive instructions",
        "correct": false
      },
      {
        "text": "transferred in any state of the processor, not just between the execution of successive instructions",
        "correct": false
      }
    ]
  },
  {
    "question": "swap area is placed in:",
    "answers": [
      {
        "text": "virtual memory",
        "correct": false
      },
      {
        "text": "index tables",
        "correct": false
      },
      {
        "text": "mass memory",
        "correct": true
      },
      {
        "text": "primary memory",
        "correct": false
      }
    ]
  },
  {
    "question": "conditional variables in a monitor",
    "answers": [
      {
        "text": "they are used to check whether the conditions for process continuation are met",
        "correct": false
      },
      {
        "text": "they guard access to the critical region of the monitor",
        "correct": false
      },
      {
        "text": "they are used to suspend processes that cannot run because the conditions for their continuation are not met",
        "correct": true
      }
    ]
  },
  {
    "question": "on unix, the number of files is directly limited by:",
    "answers": [
      {
        "text": "the size of the space allocated for files",
        "correct": true
      },
      {
        "text": "fat size",
        "correct": false
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      },
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      }
    ]
  },
  {
    "question": "the scheduler decisions take the form:",
    "answers": [
      {
        "text": "change from ready to active state",
        "correct": true
      },
      {
        "text": "change from ready to waiting state",
        "correct": false
      },
      {
        "text": "change from waiting to ready state",
        "correct": false
      },
      {
        "text": "change from active to ready state",
        "correct": false
      }
    ]
  },
  {
    "question": "what does the file system layer do?",
    "answers": [
      {
        "text": "manages remote files",
        "correct": false
      },
      {
        "text": "keeps track of how information is recorded",
        "correct": true
      },
      {
        "text": "manages remote file systems",
        "correct": false
      },
      {
        "text": "tracks the location of the data",
        "correct": true
      }
    ]
  },
  {
    "question": "if the compiler prepares a program with absolute addresses to be loaded in a fixed address space, it is called:",
    "answers": [
      {
        "text": "static relocation",
        "correct": true
      },
      {
        "text": "dynamic compiling",
        "correct": false
      },
      {
        "text": "dynamic relocation",
        "correct": false
      },
      {
        "text": "static compiling",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is used to preserve the states of preempted tasks?",
    "answers": [
      {
        "text": "time slice",
        "correct": false
      },
      {
        "text": "context switch",
        "correct": true
      },
      {
        "text": "batch work",
        "correct": false
      },
      {
        "text": "task period",
        "correct": false
      }
    ]
  },
  {
    "question": "separate allocation queues for fixed memory blocks of equal size cause:",
    "answers": [
      {
        "text": "external fragmentation",
        "correct": true
      },
      {
        "text": "internal fragmentation",
        "correct": true
      },
      {
        "text": "need for compaction",
        "correct": false
      }
    ]
  },
  {
    "question": "operation v on a raised binary semaphore:",
    "answers": [
      {
        "text": "increases semaphore value by 1",
        "correct": false
      },
      {
        "text": "it is stored in order to be able to perform as many operations p as there were v",
        "correct": false
      },
      {
        "text": "it does not change the value of the semaphore",
        "correct": true
      }
    ]
  },
  {
    "question": "the use of timer interrupts is necessary:",
    "answers": [
      {
        "text": "in multiuser systems",
        "correct": true
      },
      {
        "text": "in real-time systems",
        "correct": false
      },
      {
        "text": "in multiprogram systems",
        "correct": false
      },
      {
        "text": "in concurrent systems",
        "correct": false
      }
    ]
  },
  {
    "question": "which swapping algorithms use the current time slice number?",
    "answers": [
      {
        "text": "lru",
        "correct": false
      },
      {
        "text": "clock",
        "correct": true
      },
      {
        "text": "lfu",
        "correct": false
      },
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "nru",
        "correct": false
      },
      {
        "text": "working set",
        "correct": true
      },
      {
        "text": "second chance",
        "correct": true
      },
      {
        "text": "optimal",
        "correct": false
      },
      {
        "text": "no algorithm",
        "correct": false
      }
    ]
  },
  {
    "question": "logical address:",
    "answers": [
      {
        "text": "points to a cell in the process address space",
        "correct": true
      },
      {
        "text": "points to a location in the address space of primary memory",
        "correct": false
      },
      {
        "text": "is converted to a physical address in the address translation mechanism",
        "correct": true
      },
      {
        "text": "is a relative address - relative to the program counter",
        "correct": false
      }
    ]
  },
  {
    "question": "consider the following sequence of address references:\n\n123, 215, 600, 1234, 76, 96.\n\nif the page size is 100, the order of page references is as follows:",
    "answers": [
      {
        "text": "1,2,6,12,0,0",
        "correct": true
      },
      {
        "text": "1,2,6,12",
        "correct": false
      },
      {
        "text": "0,2,6,12,0,0",
        "correct": false
      },
      {
        "text": "12,21,60,123,7,9",
        "correct": false
      }
    ]
  },
  {
    "question": "which mechanisms are supported by the phenomenon of locality of references?",
    "answers": [
      {
        "text": "reverse page index tables",
        "correct": false
      },
      {
        "text": "multilevel page index tables",
        "correct": true
      },
      {
        "text": "associative memory of page references",
        "correct": true
      },
      {
        "text": "address translation",
        "correct": false
      },
      {
        "text": "page swapping",
        "correct": true
      }
    ]
  },
  {
    "question": "using the test-and-set instruction in synchronization:",
    "answers": [
      {
        "text": "requires organizing inactive waiting in queues",
        "correct": false
      },
      {
        "text": "it requires processes to actively wait",
        "correct": true
      },
      {
        "text": "stops the processor if 0 is read",
        "correct": false
      }
    ]
  },
  {
    "question": "allocation unit for file storage:",
    "answers": [
      {
        "text": "is any integer multiple of a sector (>0)",
        "correct": false
      },
      {
        "text": "may vary between partitions",
        "correct": true
      },
      {
        "text": "may differ between files in a partition",
        "correct": false
      },
      {
        "text": "must be constant across the disk partition",
        "correct": true
      }
    ]
  },
  {
    "question": "in which swapping algorithms is it necessary to clear the r bits individually?",
    "answers": [
      {
        "text": "lfu",
        "correct": false
      },
      {
        "text": "clock",
        "correct": true
      },
      {
        "text": "working set",
        "correct": true
      },
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "optimal",
        "correct": false
      },
      {
        "text": "second chance",
        "correct": false
      },
      {
        "text": "nru",
        "correct": false
      },
      {
        "text": "no algorithm",
        "correct": false
      },
      {
        "text": "lru",
        "correct": false
      }
    ]
  },
  {
    "question": "is memory protection useless in a non-concurrent system?",
    "answers": [
      {
        "text": "prawda",
        "correct": false
      },
      {
        "text": "fałsz",
        "correct": true
      }
    ]
  },
  {
    "question": "address translation aims to:",
    "answers": [
      {
        "text": "detecting the phenomenon of locality of references",
        "correct": false
      },
      {
        "text": "converting a virtual address to a physical one",
        "correct": true
      },
      {
        "text": "converting a physical address to a virtual one",
        "correct": false
      },
      {
        "text": "generating a 'frame error' interrupt when the page is out of memory",
        "correct": false
      }
    ]
  },
  {
    "question": "address translation aims to:",
    "answers": [
      {
        "text": "detecting the phenomenon of locality of references",
        "correct": false
      },
      {
        "text": "converting a physical address to a virtual one",
        "correct": false
      },
      {
        "text": "generating a 'frame error' interrupt when the page is out of memory",
        "correct": false
      },
      {
        "text": "converting a virtual address to a physical one",
        "correct": true
      }
    ]
  },
  {
    "question": "the microkernel of the operating system performs the following role:",
    "answers": [
      {
        "text": "it receives interrupts and routes them to the appropriate drivers and other layers of the system",
        "correct": true
      },
      {
        "text": "synchronizes processes",
        "correct": true
      },
      {
        "text": "runs programs",
        "correct": false
      }
    ]
  },
  {
    "question": "the environment in which the process is executed includes:",
    "answers": [
      {
        "text": "a set of environment variables",
        "correct": true
      },
      {
        "text": "contents of the interrupt request register",
        "correct": false
      },
      {
        "text": "process address space",
        "correct": true
      },
      {
        "text": "the content in the memory management unit",
        "correct": false
      }
    ]
  },
  {
    "question": "what does it mean that the interrupt subsystem is vectored (all components of the correct answer must be given)?",
    "answers": [
      {
        "text": "there is an interrupt handling table indexed by the interrupt line number",
        "correct": true
      },
      {
        "text": "interrupts are accepted on multiple input lines",
        "correct": true
      },
      {
        "text": "there is an individual interrupt mask",
        "correct": true
      },
      {
        "text": "uses interrupt vector in interrupt handling",
        "correct": true
      }
    ]
  },
  {
    "question": "a program compiled to be executed in contiguous memory can be executed in paged memory.",
    "answers": [
      {
        "text": "prawda",
        "correct": true
      },
      {
        "text": "fałsz",
        "correct": false
      }
    ]
  },
  {
    "question": "if the loader inserts a program with absolute addresses into a fixed address space, it is called:",
    "answers": [
      {
        "text": "static loading",
        "correct": false
      },
      {
        "text": "dynamic loading",
        "correct": false
      },
      {
        "text": "dynamic relocation",
        "correct": true
      },
      {
        "text": "static relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "fragmentation is implied by:",
    "answers": [
      {
        "text": "external by resizing allocated blocks",
        "correct": true
      },
      {
        "text": "internal by partitioning into quantized blocks",
        "correct": true
      },
      {
        "text": "internal by paging",
        "correct": true
      },
      {
        "text": "external by freeing blocks in a deallocation order not reverse to allocation",
        "correct": true
      },
      {
        "text": "external by segmentation",
        "correct": false
      }
    ]
  },
  {
    "question": "allocation unit for file storage:",
    "answers": [
      {
        "text": "may differ between files in a partition",
        "correct": false
      },
      {
        "text": "it should be selected to match the characteristics of the data",
        "correct": false
      },
      {
        "text": "may vary between partitions",
        "correct": true
      },
      {
        "text": "may be a variable in a partition",
        "correct": false
      }
    ]
  },
  {
    "question": "in the running state, there is a process that:",
    "answers": [
      {
        "text": "fills the cpu idle time",
        "correct": false
      },
      {
        "text": "waits for a processor",
        "correct": false
      },
      {
        "text": "waits for an i/o operation to complete",
        "correct": false
      },
      {
        "text": "occupies a processor",
        "correct": true
      }
    ]
  },
  {
    "question": "the process context includes:",
    "answers": [
      {
        "text": "general purpose registers",
        "correct": true
      },
      {
        "text": "external devices registers",
        "correct": false
      },
      {
        "text": "process descriptor",
        "correct": true
      },
      {
        "text": "the content of the file containing the program",
        "correct": false
      }
    ]
  },
  {
    "question": "in the case of hardware interrupt summation (\"wire or\"):",
    "answers": [
      {
        "text": "the bus driver can poll devices about issuing an interrupt",
        "correct": true
      },
      {
        "text": "the processor can programatically poll devices about issuing an interrupt",
        "correct": true
      },
      {
        "text": "the interrupt circuit can query devices about issuing an interrupt",
        "correct": false
      },
      {
        "text": "the interrupt source is identified by a special bus signal",
        "correct": false
      }
    ]
  },
  {
    "question": "the kernel (microkernel) is responsible for:",
    "answers": [
      {
        "text": "task control",
        "correct": true
      },
      {
        "text": "memory allocation and freeing",
        "correct": false
      },
      {
        "text": "interrupt handling (at the elementary level, then they are passed on to other layers).",
        "correct": true
      },
      {
        "text": "synchronization of processes and devices with processes",
        "correct": true
      }
    ]
  },
  {
    "question": "virtual memory consists of:",
    "answers": [
      {
        "text": "cache and storage memory",
        "correct": false
      },
      {
        "text": "main memory and cache",
        "correct": false
      },
      {
        "text": "primary memory and storage memory",
        "correct": true
      },
      {
        "text": "primary memory and cloud storage",
        "correct": false
      }
    ]
  },
  {
    "question": "for concurrency in os:",
    "answers": [
      {
        "text": "cache memory is necessary",
        "correct": false
      },
      {
        "text": "special processor support is required",
        "correct": true
      },
      {
        "text": "interrupt handling is necessary",
        "correct": true
      },
      {
        "text": "timer interrupts are necessary",
        "correct": false
      }
    ]
  },
  {
    "question": "which technique was introduced because a single task could occupy both the cpu and i/o devices?",
    "answers": [
      {
        "text": "interrupts",
        "correct": true
      },
      {
        "text": "multiprogramming",
        "correct": false
      },
      {
        "text": "preemptive scheduling",
        "correct": false
      },
      {
        "text": "buffering",
        "correct": false
      }
    ]
  },
  {
    "question": "the system stack must provide space for:",
    "answers": [
      {
        "text": "cpu registers",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines and possible software interrupts",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are devices in the system +1",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines +1",
        "correct": true
      }
    ]
  },
  {
    "question": "memory partitioning into blocks of any size:",
    "answers": [
      {
        "text": "it does not imply fragmentation",
        "correct": true
      },
      {
        "text": "it implies external fragmentation",
        "correct": false
      },
      {
        "text": "it implies internal fragmentation",
        "correct": false
      }
    ]
  },
  {
    "question": "the optimal scheduling algorithm in terms of minimizing the average time in the system of a given task is:",
    "answers": [
      {
        "text": "sjf",
        "correct": true
      },
      {
        "text": "fcfs",
        "correct": false
      },
      {
        "text": "time slicing",
        "correct": false
      },
      {
        "text": "priority",
        "correct": false
      }
    ]
  },
  {
    "question": "in multi-level interrupts (vectored interrupts) the jump is performed:",
    "answers": [
      {
        "text": "to the address specified in the given processor register",
        "correct": false
      },
      {
        "text": "according to the table indexed by the interrupt number",
        "correct": true
      },
      {
        "text": "to the address contained in the device driver, provided by the i/o instruction",
        "correct": false
      },
      {
        "text": "to a fixed address",
        "correct": false
      }
    ]
  },
  {
    "question": "on unix, the number of files is directly limited by:",
    "answers": [
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "i-node table size",
        "correct": true
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      },
      {
        "text": "the size of the space allocated for files",
        "correct": true
      }
    ]
  },
  {
    "question": "paging - the key in associative memory is:",
    "answers": [
      {
        "text": "the page number concatenated with the frame number",
        "correct": false
      },
      {
        "text": "page number",
        "correct": true
      },
      {
        "text": "frame number",
        "correct": false
      },
      {
        "text": "the frame number concatenated with the page number",
        "correct": false
      }
    ]
  },
  {
    "question": "the hardware resources of a computer system are:",
    "answers": [
      {
        "text": "peripheral devioces",
        "correct": false
      },
      {
        "text": "processor time",
        "correct": true
      },
      {
        "text": "windows on the screen",
        "correct": false
      },
      {
        "text": "virtual memory",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following facilities or abilities are required to provide mutual exclusion support?",
    "answers": [
      {
        "text": "task scheduling must be considered.",
        "correct": false
      },
      {
        "text": "the task stays in its critical section only for a finite amount of time.",
        "correct": true
      },
      {
        "text": "a task that is performed outside the critical section must not affect the behavior of a task in the critical section.",
        "correct": true
      },
      {
        "text": "the relative speeds of the tasks must be taken into account.",
        "correct": false
      }
    ]
  },
  {
    "question": "is memory protection useless in a single program system?",
    "answers": [
      {
        "text": "prawda",
        "correct": false
      },
      {
        "text": "fałsz",
        "correct": true
      }
    ]
  },
  {
    "question": "which swapping algorithms can be implemented based on hardware support in the form of a collective reading of reference bits and collective clearing of these bits?",
    "answers": [
      {
        "text": "optimal",
        "correct": false
      },
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "lru",
        "correct": true
      },
      {
        "text": "working set",
        "correct": false
      },
      {
        "text": "second chance",
        "correct": false
      },
      {
        "text": "nru",
        "correct": false
      },
      {
        "text": "no algorithm",
        "correct": false
      },
      {
        "text": "lfu",
        "correct": true
      },
      {
        "text": "working set clock",
        "correct": false
      }
    ]
  },
  {
    "question": "context switch is:",
    "answers": [
      {
        "text": "calling the kernel of the operating system",
        "correct": false
      },
      {
        "text": "writing registers to the task stack and retrieving them from another task stack",
        "correct": true
      },
      {
        "text": "extracode execution",
        "correct": false
      },
      {
        "text": "switching to the system stack",
        "correct": false
      }
    ]
  },
  {
    "question": "onion algorithm:",
    "answers": [
      {
        "text": "causes internal fragmentation",
        "correct": true
      },
      {
        "text": "causes external fragmentation",
        "correct": true
      },
      {
        "text": "reduces external fragmentation by aligning the allocation order with the process hierarchy",
        "correct": true
      }
    ]
  },
  {
    "question": "during the interrupt handling:",
    "answers": [
      {
        "text": "other interrupts may or may not be accepted at the discretion of the programmer",
        "correct": true
      },
      {
        "text": "other interrupts are disabled",
        "correct": false
      },
      {
        "text": "other interrupts can be accepted",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is part of time-sharing systems?",
    "answers": [
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "medium-level scheduler",
        "correct": false
      },
      {
        "text": "low-level scheduler",
        "correct": true
      },
      {
        "text": "high-level scheduler",
        "correct": false
      }
    ]
  },
  {
    "question": "how does the operating system call the task completion subroutine?",
    "answers": [
      {
        "text": "recreates the context programmatically and executes the iret instruction",
        "correct": true
      },
      {
        "text": "builds an interrupt vector on the system stack pointing to the terminating subroutine code",
        "correct": false
      },
      {
        "text": "sets the trace in the terminating subroutine to the current position",
        "correct": false
      },
      {
        "text": "builds the frame of the terminating subroutine on the task stack",
        "correct": false
      }
    ]
  },
  {
    "question": "at the ready state is a process that:",
    "answers": [
      {
        "text": "waits for an i/o operation to complete",
        "correct": false
      },
      {
        "text": "occupies a processor",
        "correct": false
      },
      {
        "text": "fills the processor idle time",
        "correct": false
      },
      {
        "text": "waits for a processor",
        "correct": true
      }
    ]
  },
  {
    "question": "in unix, access rights are attributes:",
    "answers": [
      {
        "text": "a special table specifying access rights",
        "correct": false
      },
      {
        "text": "an entry in the i-node table",
        "correct": true
      },
      {
        "text": "user descriptor",
        "correct": false
      },
      {
        "text": "a directory entry for a file",
        "correct": false
      }
    ]
  },
  {
    "question": "logical address:",
    "answers": [
      {
        "text": "is converted to a physical address in the address translation mechanism",
        "correct": true
      },
      {
        "text": "points to a cell in the process address space",
        "correct": true
      },
      {
        "text": "is a relative address - relative to the program counter",
        "correct": false
      },
      {
        "text": "points to a location in the address space of primary memory",
        "correct": false
      }
    ]
  },
  {
    "question": "opening a file in unix writes the following entries in the operating system's data structures:",
    "answers": [
      {
        "text": "inserting a new entry into the table of active i-nodes or increasing the counter in an existing entry",
        "correct": true
      },
      {
        "text": "inserting a new item into the table of open files of the process",
        "correct": true
      },
      {
        "text": "inserting a new entry into the system table of open files or incrementing a counter in an existing entry",
        "correct": false
      }
    ]
  },
  {
    "question": "the microkernel of the operating system performs the following role:",
    "answers": [
      {
        "text": "runs programs",
        "correct": false
      },
      {
        "text": "synchronizes processes",
        "correct": true
      },
      {
        "text": "it receives interrupts and routes them to the appropriate drivers and other layers of the system",
        "correct": true
      }
    ]
  },
  {
    "question": "the process context includes:",
    "answers": [
      {
        "text": "general purpose registers",
        "correct": true
      },
      {
        "text": "external devices registers",
        "correct": false
      },
      {
        "text": "process descriptor",
        "correct": true
      },
      {
        "text": "the content of the file containing the program",
        "correct": false
      }
    ]
  },
  {
    "question": "in multi-level interrupts (vectored interrupts) the jump is performed:",
    "answers": [
      {
        "text": "to the address contained in the device driver, provided by the i/o instruction",
        "correct": false
      },
      {
        "text": "according to the table indexed by the interrupt number",
        "correct": true
      },
      {
        "text": "to the address specified in the given processor register",
        "correct": false
      },
      {
        "text": "to a fixed address",
        "correct": false
      }
    ]
  },
  {
    "question": "lru algorithm consists in:",
    "answers": [
      {
        "text": "removing the least used page from memory",
        "correct": false
      },
      {
        "text": "downloading to the memory of the page that will be needed as soon as possible",
        "correct": false
      },
      {
        "text": "ejecting the most recently used page from memory",
        "correct": true
      },
      {
        "text": "downloading to memory the page that is most often needed",
        "correct": false
      }
    ]
  },
  {
    "question": "what are the functions of the kernel?",
    "answers": [
      {
        "text": "file management",
        "correct": false
      },
      {
        "text": "program management",
        "correct": false
      },
      {
        "text": "interrupt handling",
        "correct": true
      },
      {
        "text": "memory management",
        "correct": false
      }
    ]
  },
  {
    "question": "the scheduling goal, which is to occupy processors as efficiently as possible, is:",
    "answers": [
      {
        "text": "utilization",
        "correct": true
      },
      {
        "text": "productivity",
        "correct": false
      },
      {
        "text": "response time",
        "correct": false
      }
    ]
  },
  {
    "question": "during the interrupt handling:",
    "answers": [
      {
        "text": "other interrupts may or may not be accepted at the discretion of the programmer",
        "correct": true
      },
      {
        "text": "other interrupts can be accepted",
        "correct": false
      },
      {
        "text": "other interrupts are disabled",
        "correct": false
      }
    ]
  },
  {
    "question": "by definition, a deadlock is a situation where:",
    "answers": [
      {
        "text": "any greater than one number of processes are waiting for conditions that cannot be met",
        "correct": false
      },
      {
        "text": "at least two processes are waiting for conditions that cannot be met",
        "correct": true
      },
      {
        "text": "exactly two processes are waiting for conditions that cannot be met",
        "correct": false
      },
      {
        "text": "any greater than zero number of processes are waiting for conditions that cannot be met",
        "correct": false
      }
    ]
  },
  {
    "question": "the environment in which the process is executed includes:",
    "answers": [
      {
        "text": "contents of the interrupt request register",
        "correct": false
      },
      {
        "text": "general purpose registers content",
        "correct": true
      },
      {
        "text": "the content in the memory management unit",
        "correct": false
      },
      {
        "text": "open files",
        "correct": true
      }
    ]
  },
  {
    "question": "the operating system plays the following role in a computer system:",
    "answers": [
      {
        "text": "relational database management",
        "correct": false
      },
      {
        "text": "creating abstraction (virtualization) of hardware",
        "correct": true
      },
      {
        "text": "create a concurrent environment",
        "correct": true
      },
      {
        "text": "computer system resource management",
        "correct": true
      }
    ]
  },
  {
    "question": "scheduling algorithms can be:",
    "answers": [
      {
        "text": "indulgent",
        "correct": false
      },
      {
        "text": "interrupting",
        "correct": false
      },
      {
        "text": "term changing",
        "correct": false
      },
      {
        "text": "preemptive",
        "correct": true
      }
    ]
  },
  {
    "question": "general semaphore:",
    "answers": [
      {
        "text": "can be only non-negative",
        "correct": true
      },
      {
        "text": "is to perform only indvisible operations",
        "correct": true
      },
      {
        "text": "is a shared variable",
        "correct": true
      },
      {
        "text": "requires busy waiting",
        "correct": false
      }
    ]
  },
  {
    "question": "the key in associative memory is:",
    "answers": [
      {
        "text": "page number",
        "correct": true
      },
      {
        "text": "frame number",
        "correct": false
      },
      {
        "text": "the frame number concatenated with the page number",
        "correct": false
      },
      {
        "text": "the page number concatenated with the frame number",
        "correct": false
      }
    ]
  },
  {
    "question": "the purpose of mutual exclusion is:",
    "answers": [
      {
        "text": "secure context switch",
        "correct": false
      },
      {
        "text": "interrupt service",
        "correct": false
      },
      {
        "text": "obtaining exclusive access",
        "correct": true
      },
      {
        "text": "deadlock prevention",
        "correct": false
      }
    ]
  },
  {
    "question": "the following situations trigger 'error' exceptions:",
    "answers": [
      {
        "text": "attempting to execute an illegal instruction",
        "correct": true
      },
      {
        "text": "attempting to execute in user mode an instruction that is only legal in system mode",
        "correct": true
      },
      {
        "text": "extracode",
        "correct": false
      },
      {
        "text": "page fault (also known as frame fault, frame error, page miss)",
        "correct": false
      }
    ]
  },
  {
    "question": "in a fat-based disk system (without sharing allocation units by files), the number of files is directly limited by:",
    "answers": [
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      },
      {
        "text": "fat table size",
        "correct": true
      },
      {
        "text": "the size of the disk space",
        "correct": true
      },
      {
        "text": "allocation unit size",
        "correct": false
      }
    ]
  },
  {
    "question": "two successive executions of operation v in one process on a binary semaphore in down state:",
    "answers": [
      {
        "text": "it doesn't change anything",
        "correct": false
      },
      {
        "text": "increases semaphore value by 2",
        "correct": false
      },
      {
        "text": "if the semaphore guards a critical region, it can lets two processes enter the critical region",
        "correct": true
      },
      {
        "text": "raises the semaphore if there are no suspended processes",
        "correct": true
      }
    ]
  },
  {
    "question": "the mechanism for moving programs between primary memory and mass storage is called:",
    "answers": [
      {
        "text": "leaching",
        "correct": false
      },
      {
        "text": "sweeping",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": true
      },
      {
        "text": "leading out",
        "correct": false
      }
    ]
  },
  {
    "question": "onion algorithm:",
    "answers": [
      {
        "text": "reduces external fragmentation by aligning the allocation order with the process hierarchy",
        "correct": true
      },
      {
        "text": "causes external fragmentation",
        "correct": true
      },
      {
        "text": "causes internal fragmentation",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation requires the use of:",
    "answers": [
      {
        "text": "status register",
        "correct": false
      },
      {
        "text": "base register (datum)",
        "correct": true
      },
      {
        "text": "limit register",
        "correct": false
      },
      {
        "text": "program counter",
        "correct": false
      }
    ]
  },
  {
    "question": "the number of condition variables is by definition in the monitor:",
    "answers": [
      {
        "text": "as many as there are different conditions for the continuation of processes plus one for mutual exclusion",
        "correct": false
      },
      {
        "text": "two",
        "correct": false
      },
      {
        "text": "as many as there are different conditions for the continuation of processes",
        "correct": true
      },
      {
        "text": "one",
        "correct": false
      }
    ]
  },
  {
    "question": "what paging element is not used in real-time systems?",
    "answers": [
      {
        "text": "address translation",
        "correct": false
      },
      {
        "text": "page swapping",
        "correct": true
      },
      {
        "text": "reference bits",
        "correct": false
      },
      {
        "text": "protection bits",
        "correct": false
      }
    ]
  },
  {
    "question": "a memory management technique in which the system divides memory into equal-sized portions to easily manage relocation is called:",
    "answers": [
      {
        "text": "sweeping",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "paging",
        "correct": true
      },
      {
        "text": "mapping",
        "correct": false
      }
    ]
  },
  {
    "question": "if a linker prepares a program with absolute addresses to be loaded in a fixed address space, it is called:",
    "answers": [
      {
        "text": "static linking",
        "correct": true
      },
      {
        "text": "dynamic relocation",
        "correct": false
      },
      {
        "text": "dynamic linking",
        "correct": false
      },
      {
        "text": "static relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "effective address is:",
    "answers": [
      {
        "text": "physical address",
        "correct": false
      },
      {
        "text": "relative address",
        "correct": false
      },
      {
        "text": "logical address",
        "correct": true
      },
      {
        "text": "indirect address",
        "correct": false
      }
    ]
  },
  {
    "question": "\"soft\" real-time system:",
    "answers": [
      {
        "text": "guarantees average response time",
        "correct": true
      },
      {
        "text": "guaranteed response time",
        "correct": false
      },
      {
        "text": "guarantees interrupt handling time",
        "correct": false
      }
    ]
  },
  {
    "question": "address translation aims to:",
    "answers": [
      {
        "text": "converting a physical address to a virtual one",
        "correct": false
      },
      {
        "text": "generating a \"frame error\" interrupt when the page is out of memory",
        "correct": false
      },
      {
        "text": "converting a virtual address to a physical one",
        "correct": true
      },
      {
        "text": "detecting the phenomenon of locality of references",
        "correct": false
      }
    ]
  },
  {
    "question": "which swapping algorithms use page reference history?",
    "answers": [
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "working set",
        "correct": false
      },
      {
        "text": "lru",
        "correct": true
      },
      {
        "text": "lfu",
        "correct": true
      },
      {
        "text": "working set clock",
        "correct": false
      },
      {
        "text": "nru",
        "correct": false
      },
      {
        "text": "second chance",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following memory allocation schemes cause external fragmentation?",
    "answers": [
      {
        "text": "paging",
        "correct": false
      },
      {
        "text": "multiple contiguous fixed partitions of equal size",
        "correct": false
      },
      {
        "text": "segmentation",
        "correct": true
      },
      {
        "text": "sweeping",
        "correct": true
      }
    ]
  },
  {
    "question": "in a fat-based disk system, file size is directly limited by:",
    "answers": [
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "the size of the disk space",
        "correct": true
      },
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": true
      },
      {
        "text": "fat table size",
        "correct": false
      }
    ]
  },
  {
    "question": "interrupt vector:",
    "answers": [
      {
        "text": "contains the instruction counter, condition bits, interrupt mask, and general purpose registers",
        "correct": false
      },
      {
        "text": "it is saved automatically when an interrupt is accepted",
        "correct": true
      },
      {
        "text": "contains minimal information that cannot be saved programmatically",
        "correct": true
      },
      {
        "text": "contains the id of the process that should be restarted",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is part of time-sharing systems?",
    "answers": [
      {
        "text": "low-level scheduler",
        "correct": true
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "medium-level scheduler",
        "correct": false
      },
      {
        "text": "high-level scheduler",
        "correct": false
      }
    ]
  },
  {
    "question": "on what system is it not worth using memory protection?",
    "answers": [
      {
        "text": "without os",
        "correct": true
      },
      {
        "text": "not concurrent",
        "correct": false
      },
      {
        "text": "one-user",
        "correct": false
      },
      {
        "text": "one-program",
        "correct": false
      }
    ]
  },
  {
    "question": "the software resources of a computer system are:",
    "answers": [
      {
        "text": "semaphores",
        "correct": true
      },
      {
        "text": "buffers",
        "correct": true
      },
      {
        "text": "files",
        "correct": true
      },
      {
        "text": "primary memory",
        "correct": false
      }
    ]
  },
  {
    "question": "which swapping algorithms use the history of page references (when was it last used or in which time slices was it used)?",
    "answers": [
      {
        "text": "no algorithm",
        "correct": false
      },
      {
        "text": "working set",
        "correct": true
      },
      {
        "text": "lfu",
        "correct": true
      },
      {
        "text": "nru",
        "correct": false
      },
      {
        "text": "clock",
        "correct": false
      },
      {
        "text": "lru",
        "correct": true
      },
      {
        "text": "fifo",
        "correct": false
      },
      {
        "text": "second chance",
        "correct": true
      }
    ]
  },
  {
    "question": "a multiprogram system is one that, in principle:",
    "answers": [
      {
        "text": "it allows for running programs only one after another",
        "correct": false
      },
      {
        "text": "it allows for storing many programs in primary memory",
        "correct": true
      },
      {
        "text": "requires relocation or equivalent mechanism",
        "correct": true
      },
      {
        "text": "requires dynamic relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "context switch is:",
    "answers": [
      {
        "text": "calling the kernel of the operating system",
        "correct": false
      },
      {
        "text": "switching to the system stack",
        "correct": false
      },
      {
        "text": "writing registers to the task stack and retrieving them from another task stack",
        "correct": true
      },
      {
        "text": "extracode execution",
        "correct": false
      }
    ]
  },
  {
    "question": "devices report their readiness by:",
    "answers": [
      {
        "text": "issuing an interrupt",
        "correct": true
      },
      {
        "text": "setting a status bit",
        "correct": true
      },
      {
        "text": "unblocking the interrupts",
        "correct": false
      },
      {
        "text": "system call",
        "correct": false
      }
    ]
  },
  {
    "question": "internal fragmentation consists in:",
    "answers": [
      {
        "text": "discontinuous program memory allocation",
        "correct": false
      },
      {
        "text": "free memory blocks between allocated blocks",
        "correct": false
      },
      {
        "text": "the program does not use all the memory allocated to it",
        "correct": true
      },
      {
        "text": "dividing the memory allocated to the program into a data area and a code area",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following memory allocation schemes can cause external fragmentation?",
    "answers": [
      {
        "text": "segmentation",
        "correct": true
      },
      {
        "text": "multiple contiguous fixed partitions of equal size",
        "correct": false
      },
      {
        "text": "multiple contiguous fixed partitions of various sizes",
        "correct": true
      },
      {
        "text": "sweeping",
        "correct": true
      }
    ]
  },
  {
    "question": "clean frame is:",
    "answers": [
      {
        "text": "modified",
        "correct": false
      },
      {
        "text": "not modified",
        "correct": true
      },
      {
        "text": "empty, where the page has not yet been loaded",
        "correct": false
      },
      {
        "text": "candidate to be swapped last",
        "correct": false
      }
    ]
  },
  {
    "question": "address translation mechanism:",
    "answers": [
      {
        "text": "adds the frame number to the page number",
        "correct": false
      },
      {
        "text": "concatenates the frame number and page number",
        "correct": false
      },
      {
        "text": "concatenates the frame number and offset on the page",
        "correct": true
      },
      {
        "text": "concatenates the page number and page offset",
        "correct": false
      }
    ]
  },
  {
    "question": "round-robin scheduling is the best mechanism for:",
    "answers": [
      {
        "text": "time-sharing system",
        "correct": true
      },
      {
        "text": "system with different classes of tasks",
        "correct": false
      },
      {
        "text": "every system",
        "correct": false
      },
      {
        "text": "real-time system",
        "correct": false
      }
    ]
  },
  {
    "question": "page thrashing is a phenomenon involving:",
    "answers": [
      {
        "text": "frequent downloading of pages that have just been swapped out from memory",
        "correct": true
      },
      {
        "text": "frequently changing the values of bits describing pages in frames",
        "correct": false
      },
      {
        "text": "frequent context changes that require page index tables to be reloaded",
        "correct": false
      },
      {
        "text": "loading the same page over and over again",
        "correct": false
      }
    ]
  },
  {
    "question": "internal fragmentation can be removed by:",
    "answers": [
      {
        "text": "movement of allocated blocks in memory",
        "correct": false
      },
      {
        "text": "transferring allocated memory blocks to disk",
        "correct": false
      },
      {
        "text": "the use of the \"onion\" algorithm",
        "correct": false
      },
      {
        "text": "allocating unused portions of memory within blocks to other programs",
        "correct": false
      },
      {
        "text": "no response from the others",
        "correct": true
      }
    ]
  },
  {
    "question": "on unix, the number of files is directly limited by:",
    "answers": [
      {
        "text": "i-node table size",
        "correct": true
      },
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "the size of the space allocated for files",
        "correct": true
      },
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      }
    ]
  },
  {
    "question": "which task queue can never be empty?",
    "answers": [
      {
        "text": "swept away tasks",
        "correct": false
      },
      {
        "text": "suspended tasks",
        "correct": false
      },
      {
        "text": "ready tasks",
        "correct": false
      },
      {
        "text": "running tasks",
        "correct": true
      }
    ]
  },
  {
    "question": "what is this technique where the operating system gathers programs and data together before processing?",
    "answers": [
      {
        "text": "real-time processing",
        "correct": false
      },
      {
        "text": "distributed processing",
        "correct": false
      },
      {
        "text": "batch processing",
        "correct": true
      },
      {
        "text": "interactive processing",
        "correct": false
      }
    ]
  },
  {
    "question": "when the processor is released, the scheduler selects one of the queued processes:",
    "answers": [
      {
        "text": "running",
        "correct": true
      },
      {
        "text": "ready",
        "correct": false
      },
      {
        "text": "suspended",
        "correct": false
      },
      {
        "text": "waiting",
        "correct": false
      }
    ]
  },
  {
    "question": "which mechanisms are supported by the phenomenon of locality of references?",
    "answers": [
      {
        "text": "address translation",
        "correct": false
      },
      {
        "text": "reverse page index tables",
        "correct": true
      },
      {
        "text": "page swapping",
        "correct": true
      },
      {
        "text": "multilevel page index tables",
        "correct": true
      },
      {
        "text": "associative memory of page references",
        "correct": true
      }
    ]
  },
  {
    "question": "when is the scheduler called?",
    "answers": [
      {
        "text": "at the start of execution of each kernel procedure",
        "correct": false
      },
      {
        "text": "at the request of a user task",
        "correct": false
      },
      {
        "text": "when the scheduler decides itself",
        "correct": false
      },
      {
        "text": "at the end of the execution of each kernel procedure",
        "correct": true
      }
    ]
  },
  {
    "question": "for address translation, the following is used:",
    "answers": [
      {
        "text": "associative translation buffer",
        "correct": false
      },
      {
        "text": "reference and protection bits",
        "correct": false
      },
      {
        "text": "translation register",
        "correct": false
      },
      {
        "text": "index table",
        "correct": true
      }
    ]
  },
  {
    "question": "the program supervisor layer in the operating system has the following role:",
    "answers": [
      {
        "text": "deals with the management of primary memory (memory allocation to programs)",
        "correct": true
      },
      {
        "text": "deals with buffering data written and read from mass memory",
        "correct": false
      },
      {
        "text": "intercepts all program system calls and routes them to the appropriate layers",
        "correct": true
      },
      {
        "text": "runs programs",
        "correct": true
      }
    ]
  },
  {
    "question": "in round-robin scheduling, if each task is allotted a certain amount of time to execute, it is called:",
    "answers": [
      {
        "text": "batch time",
        "correct": false
      },
      {
        "text": "time slice",
        "correct": true
      },
      {
        "text": "period",
        "correct": false
      },
      {
        "text": "work time",
        "correct": false
      }
    ]
  },
  {
    "question": "two-level tis - place frame no:",
    "answers": [
      {
        "text": "part in the first level table and part in the second level table",
        "correct": false
      },
      {
        "text": "none of the above answers",
        "correct": true
      },
      {
        "text": "in the table of the first level - on the left in the figure",
        "correct": false
      },
      {
        "text": "in the table of the second level - on the right in the figure",
        "correct": false
      }
    ]
  },
  {
    "question": "twice consecutive execution in one process of operation p on a raised binary semaphore:",
    "answers": [
      {
        "text": "causes the semaphore to get down",
        "correct": true
      },
      {
        "text": "decreases semaphore value by 2",
        "correct": false
      },
      {
        "text": "it doesn't change anything",
        "correct": false
      },
      {
        "text": "if a semaphore guards a critical region, it leads to a deadlock",
        "correct": true
      }
    ]
  },
  {
    "question": "address translation mechanism:",
    "answers": [
      {
        "text": "concatenates the frame number and offset on the page",
        "correct": true
      },
      {
        "text": "concatenates the frame number and page number",
        "correct": false
      },
      {
        "text": "adds the frame number to the page number",
        "correct": false
      },
      {
        "text": "concatenates the page number and page offset",
        "correct": false
      }
    ]
  },
  {
    "question": "discontinuous allocation is the result of:",
    "answers": [
      {
        "text": "relocation",
        "correct": false
      },
      {
        "text": "compaction",
        "correct": false
      },
      {
        "text": "paging",
        "correct": true
      },
      {
        "text": "segmantation",
        "correct": true
      }
    ]
  },
  {
    "question": "the number of tasks performed on the system in a given time is:",
    "answers": [
      {
        "text": "efficiency",
        "correct": false
      },
      {
        "text": "utilization",
        "correct": false
      },
      {
        "text": "throughput",
        "correct": true
      },
      {
        "text": "response time",
        "correct": false
      }
    ]
  },
  {
    "question": "calling the program with the \"exec\" operation results in (accurately to the result of the exec operation):",
    "answers": [
      {
        "text": "loading code and data segments from disk, initializing a new stack segment",
        "correct": true
      },
      {
        "text": "loading a code segment from disk, duplicating the data segment of the calling process",
        "correct": false
      },
      {
        "text": "loading a code segment from disk, duplicating data segments and the calling process stack",
        "correct": false
      }
    ]
  },
  {
    "question": "when an exception is raised in user mode, the operating system switches to the kernel system stack, and what happens when an exception is raised in system mode?",
    "answers": [
      {
        "text": "nothing special, it builds the context on the kernel system stack",
        "correct": true
      },
      {
        "text": "initializes the kernel system stack from the scratch",
        "correct": false
      },
      {
        "text": "switches to the next kernel system stack",
        "correct": false
      },
      {
        "text": "switches back to the application program stack",
        "correct": false
      }
    ]
  },
  {
    "question": "if the compiler prepares a program with absolute addresses to be loaded in a fixed address space, it is called:",
    "answers": [
      {
        "text": "dynamic compiling",
        "correct": false
      },
      {
        "text": "static relocation",
        "correct": true
      },
      {
        "text": "static compiling",
        "correct": false
      },
      {
        "text": "dynamic relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "what mechanism is part of batch systems?",
    "answers": [
      {
        "text": "long-term scheduler",
        "correct": true
      },
      {
        "text": "no scheduler is needed",
        "correct": false
      },
      {
        "text": "short-term scheduler",
        "correct": false
      },
      {
        "text": "medium-term scheduler",
        "correct": true
      }
    ]
  },
  {
    "question": "the content of the first (highest in the hierarchy) level of the page index table is:",
    "answers": [
      {
        "text": "second level pit address",
        "correct": true
      }
    ]
  },
  {
    "question": "what is this technique where the operating system gathers programs and data together before processing?",
    "answers": [
      {
        "text": "batch processing",
        "correct": true
      },
      {
        "text": "distributed processing",
        "correct": false
      },
      {
        "text": "interactive processing",
        "correct": false
      },
      {
        "text": "real-time processing",
        "correct": false
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "paging system",
        "correct": false
      },
      {
        "text": "loader",
        "correct": false
      },
      {
        "text": "special registers (datum)",
        "correct": true
      },
      {
        "text": "linker",
        "correct": false
      }
    ]
  },
  {
    "question": "mmu uses index tables to:",
    "answers": [
      {
        "text": "generate a relative address",
        "correct": false
      },
      {
        "text": "generating a physical address",
        "correct": true
      },
      {
        "text": "generate an effective address",
        "correct": false
      },
      {
        "text": "generate a logical address",
        "correct": false
      }
    ]
  },
  {
    "question": "if the loader inserts a program with absolute addresses into a fixed address space, it is called:",
    "answers": [
      {
        "text": "static relocation",
        "correct": false
      },
      {
        "text": "static loading",
        "correct": false
      },
      {
        "text": "dynamic loading",
        "correct": false
      },
      {
        "text": "dynamic relocation",
        "correct": true
      }
    ]
  },
  {
    "question": "the following paging exceptions allow for returning to the program after they occur:",
    "answers": [
      {
        "text": "attempt to read from the frame storing the code",
        "correct": false
      },
      {
        "text": "interrupt on write (iow)",
        "correct": true
      },
      {
        "text": "attempting to write to a write-protected frame",
        "correct": true
      },
      {
        "text": "page fault",
        "correct": true
      }
    ]
  },
  {
    "question": "the algorithm in which the most recently loaded page is swapped out is called (enter the abbreviation if applicable):",
    "answers": []
  },
  {
    "question": "if a linker prepares a program with absolute addresses to be loaded in a fixed address space, it is called:",
    "answers": [
      {
        "text": "dynamic linking",
        "correct": false
      },
      {
        "text": "static linking",
        "correct": true
      },
      {
        "text": "dynamic relocation",
        "correct": false
      },
      {
        "text": "static relocation",
        "correct": false
      }
    ]
  },
  {
    "question": "conditional variables in a monitor",
    "answers": [
      {
        "text": "they are used to check whether the conditions for process continuation are met",
        "correct": false
      },
      {
        "text": "they guard access to the critical region of the monitor",
        "correct": false
      },
      {
        "text": "they are used to suspend processes that cannot run because the conditions for their continuation are not met",
        "correct": true
      }
    ]
  },
  {
    "question": "sequence of actions when starting a new task:",
    "answers": [
      {
        "text": "filling in the descriptor in the kernel",
        "correct": true
      },
      {
        "text": "memory allocation if this is the first task of the program",
        "correct": true
      },
      {
        "text": "initialize the stack, fill the first frame",
        "correct": true
      },
      {
        "text": "instruction to transfer control to the task",
        "correct": true
      }
    ]
  },
  {
    "question": "which of the following facilities or abilities are required to provide mutual exclusion support?",
    "answers": [
      {
        "text": "task scheduling must be considered.",
        "correct": false
      },
      {
        "text": "the relative speeds of the tasks must be taken into account.",
        "correct": false
      },
      {
        "text": "the task stays in its critical section only for a finite amount of time.",
        "correct": true
      },
      {
        "text": "a task that is performed outside the critical section must not affect the behavior of a task in the critical section.",
        "correct": true
      }
    ]
  },
  {
    "question": "in round-robin scheduling, if each task is allotted a certain amount of time to execute, it is called:",
    "answers": [
      {
        "text": "time slice",
        "correct": true
      },
      {
        "text": "work time",
        "correct": false
      },
      {
        "text": "period",
        "correct": false
      },
      {
        "text": "batch time",
        "correct": false
      }
    ]
  },
  {
    "question": "the mechanism for moving programs between primary memory and mass storage is called:",
    "answers": [
      {
        "text": "sweeping",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": true
      },
      {
        "text": "leading out",
        "correct": false
      },
      {
        "text": "leaching",
        "correct": false
      }
    ]
  },
  {
    "question": "the page fault interrupt is used to:",
    "answers": [
      {
        "text": "whether the frame is empty or contains a page",
        "correct": false
      },
      {
        "text": "detection of an access attempt from a frame not allocated to the program",
        "correct": false
      },
      {
        "text": "downloads to the memory of the requested page",
        "correct": true
      },
      {
        "text": "detection of an attempt to write outside the address space of the frame",
        "correct": false
      }
    ]
  },
  {
    "question": "a typical collection of program segments includes (come of them can be combined):",
    "answers": [
      {
        "text": "processor registers segment",
        "correct": false
      },
      {
        "text": "stack segment",
        "correct": true
      },
      {
        "text": "code segment",
        "correct": true
      },
      {
        "text": "page index tables segment",
        "correct": false
      },
      {
        "text": "data segment",
        "correct": true
      }
    ]
  },
  {
    "question": "the file system layer plays the following role in the operating system:",
    "answers": [
      {
        "text": "controls file access rights",
        "correct": true
      },
      {
        "text": "it runs programs stored in files",
        "correct": false
      },
      {
        "text": "it performs directory services in the hierarchy of disk files",
        "correct": true
      },
      {
        "text": "performs file opening and closing operations",
        "correct": true
      }
    ]
  },
  {
    "question": "what are the functions of the kernel?",
    "answers": [
      {
        "text": "memory management",
        "correct": false
      },
      {
        "text": "program management",
        "correct": false
      },
      {
        "text": "interrupt handling",
        "correct": true
      },
      {
        "text": "file management",
        "correct": false
      }
    ]
  },
  {
    "question": "the purpose of mutual exclusion is:",
    "answers": [
      {
        "text": "interrupt service",
        "correct": false
      },
      {
        "text": "deadlock prevention",
        "correct": false
      },
      {
        "text": "obtaining exclusive access",
        "correct": true
      },
      {
        "text": "secure context switch",
        "correct": false
      }
    ]
  },
  {
    "question": "in the \"current\" state, there is a process that:",
    "answers": [
      {
        "text": "waits for an i/o operation to complete",
        "correct": false
      },
      {
        "text": "waits for a processor",
        "correct": false
      },
      {
        "text": "occupies a processor",
        "correct": true
      },
      {
        "text": "fills the cpu idle time",
        "correct": false
      }
    ]
  },
  {
    "question": "the direct resume rule means that:",
    "answers": [
      {
        "text": "the resuming process applies for the critical region just like other processes on monitor input",
        "correct": false
      },
      {
        "text": "the resuming process gets a critical region after the resumed process exits the monitor",
        "correct": false
      },
      {
        "text": "the resuming process loses the critical region",
        "correct": true
      },
      {
        "text": "proces wznawiający traci region krytyczny",
        "correct": true
      }
    ]
  },
  {
    "question": "on unix, the number of files is directly limited by:",
    "answers": [
      {
        "text": "the number of bits of the field describing the size of the file",
        "correct": false
      },
      {
        "text": "allocation unit size",
        "correct": false
      },
      {
        "text": "i-node table size",
        "correct": true
      },
      {
        "text": "the number of bits of the disk address",
        "correct": false
      },
      {
        "text": "the size of the space allocated for files",
        "correct": true
      }
    ]
  },
  {
    "question": "when is the scheduler called?",
    "answers": [
      {
        "text": "at the end of the execution of each kernel procedure",
        "correct": true
      },
      {
        "text": "when the scheduler decides itself",
        "correct": false
      },
      {
        "text": "at the start of execution of each kernel procedure",
        "correct": false
      },
      {
        "text": "at the request of a user task",
        "correct": false
      }
    ]
  },
  {
    "question": "in unix, access rights are attributes:",
    "answers": [
      {
        "text": "an entry in the i-node table",
        "correct": true
      },
      {
        "text": "user descriptor",
        "correct": false
      },
      {
        "text": "a special table specifying access rights",
        "correct": false
      },
      {
        "text": "a directory entry for a file",
        "correct": false
      }
    ]
  },
  {
    "question": "page thrashing is a phenomenon involving:",
    "answers": [
      {
        "text": "frequent context changes that require page index tables to be reloaded to mmu cache",
        "correct": false
      },
      {
        "text": "frequent loading of pages that have just been ejected from memory",
        "correct": true
      },
      {
        "text": "loading the same page over and over again",
        "correct": false
      },
      {
        "text": "frequently changing the values of bits describing pages in frames",
        "correct": false
      }
    ]
  },
  {
    "question": "which of the following common services can be partially provided by software other than the operating system?",
    "answers": [
      {
        "text": "manipulating the file system",
        "correct": true
      },
      {
        "text": "security and protection",
        "correct": true
      },
      {
        "text": "i/o operations",
        "correct": false
      },
      {
        "text": "running programs",
        "correct": false
      }
    ]
  },
  {
    "question": "dirty frame is:",
    "answers": [
      {
        "text": "read-only frame, tried to be written to",
        "correct": false
      },
      {
        "text": "candidate to be swapped first",
        "correct": false
      },
      {
        "text": "modified",
        "correct": true
      },
      {
        "text": "execute-only frame, tried to be read",
        "correct": false
      }
    ]
  },
  {
    "question": "is iow bit:",
    "answers": [
      {
        "text": "protection bit",
        "correct": true
      },
      {
        "text": "enable bit",
        "correct": false
      },
      {
        "text": "reference bit",
        "correct": false
      }
    ]
  },
  {
    "question": "having two-level page index tables:",
    "answers": [
      {
        "text": "the content of a level i table element is an index in a level ii table",
        "correct": false
      },
      {
        "text": "the content of a level i table element points to a level ii table",
        "correct": true
      },
      {
        "text": "the content of a level i table element is added to the content of a level ii table element",
        "correct": false
      },
      {
        "text": "the content of the level i table element is concatenated (combined) with the content of the level ii table element",
        "correct": false
      }
    ]
  },
  {
    "question": "static relocation is performed by:",
    "answers": [
      {
        "text": "compiler",
        "correct": true
      },
      {
        "text": "loader",
        "correct": true
      },
      {
        "text": "segment descriptors",
        "correct": false
      },
      {
        "text": "special registers (datum)",
        "correct": false
      }
    ]
  },
  {
    "question": "what is included in the context that must be saved for a synchronous (inter-instruction) precision interrupt?",
    "answers": [
      {
        "text": "general purpose registers",
        "correct": true
      },
      {
        "text": "program counter",
        "correct": true
      },
      {
        "text": "instruction register",
        "correct": false
      },
      {
        "text": "collective of individual interrupt mask",
        "correct": true
      }
    ]
  },
  {
    "question": "a memory management technique in which the system divides memory into equal-sized portions to easily manage relocation is called:",
    "answers": [
      {
        "text": "fragmentation",
        "correct": false
      },
      {
        "text": "mapping",
        "correct": false
      },
      {
        "text": "swapping",
        "correct": false
      },
      {
        "text": "paging",
        "correct": true
      }
    ]
  },
  {
    "question": "which scheduling is used to organize concurrency?",
    "answers": [
      {
        "text": "preempting",
        "correct": false
      },
      {
        "text": "short-term",
        "correct": true
      },
      {
        "text": "long-term",
        "correct": false
      },
      {
        "text": "medium-term",
        "correct": false
      }
    ]
  },
  {
    "question": "in unix, the disk contains the following areas:",
    "answers": [
      {
        "text": "files data",
        "correct": false
      },
      {
        "text": "directories",
        "correct": false
      },
      {
        "text": "i-node table",
        "correct": true
      },
      {
        "text": "superblock",
        "correct": true
      }
    ]
  },
  {
    "question": "imprecise interrupts can be handled:",
    "answers": [
      {
        "text": "after saving the full state of the pipeline",
        "correct": true
      },
      {
        "text": "when new instructions are suspended to be fetched into the pipeline",
        "correct": false
      },
      {
        "text": "only when the program allows accepting interrupts",
        "correct": false
      },
      {
        "text": "after clearing the pipeline from the instructions",
        "correct": true
      }
    ]
  },
  {
    "question": "when a suspended program is moved to auxiliary memory, its process state is called:",
    "answers": [
      {
        "text": "moved out",
        "correct": false
      },
      {
        "text": "exchanged",
        "correct": false
      },
      {
        "text": "swept away",
        "correct": true
      },
      {
        "text": "rinsed out",
        "correct": false
      }
    ]
  },
  {
    "question": "lru algorithm consists in:",
    "answers": [
      {
        "text": "removing the least used page from memory",
        "correct": false
      },
      {
        "text": "ejecting the most recently used page from memory",
        "correct": true
      },
      {
        "text": "downloading to memory the page that is most often needed",
        "correct": false
      },
      {
        "text": "downloading to the memory of the page that will be needed as soon as possible",
        "correct": false
      }
    ]
  },
  {
    "question": "allocation unit for storing files:",
    "answers": [
      {
        "text": "may vary between partitions",
        "correct": true
      },
      {
        "text": "may differ between files in a partition",
        "correct": false
      },
      {
        "text": "must be constant across the disk partition",
        "correct": true
      },
      {
        "text": "it should be selected to match the characteristics of the data",
        "correct": false
      }
    ]
  },
  {
    "question": "the interrupt encoder is:",
    "answers": [
      {
        "text": "a combinational circuit that computes the number of the reported and unmasked interrupt with the highest priority",
        "correct": true
      },
      {
        "text": "a combinational circuit that calculates the value of a new individual interrupt mask",
        "correct": true
      },
      {
        "text": "a register that tells the processor the interrupt number to be handled",
        "correct": false
      },
      {
        "text": "a combinational circuit that transmits to the processor the number of the interrupt to be serviced",
        "correct": true
      }
    ]
  },
  {
    "question": "what does the file system layer do?",
    "answers": [
      {
        "text": "manages directories",
        "correct": true
      },
      {
        "text": "manages relationships between files",
        "correct": false
      },
      {
        "text": "manages remote file systems",
        "correct": false
      },
      {
        "text": "manages free storage space",
        "correct": true
      },
      {
        "text": "manages remote files",
        "correct": false
      }
    ]
  },
  {
    "question": "the following situations cause 'error' exceptions (processor internal interrupts)",
    "answers": [
      {
        "text": "illegal instruction",
        "correct": true
      },
      {
        "text": "instruction legal but prohibited in user mode",
        "correct": true
      },
      {
        "text": "extracode",
        "correct": false
      }
    ]
  },
  {
    "question": "the conversion of the effective address to the physical one takes place:",
    "answers": [
      {
        "text": "in the arithmetic-logic unit",
        "correct": false
      },
      {
        "text": "in the sequencer",
        "correct": false
      },
      {
        "text": "in the bus arbiter",
        "correct": false
      },
      {
        "text": "in the memory management unit",
        "correct": true
      }
    ]
  },
  {
    "question": "the sweeping criteria include:",
    "answers": [
      {
        "text": "analysis of program execution history",
        "correct": true
      },
      {
        "text": "program state",
        "correct": true
      },
      {
        "text": "priority",
        "correct": true
      },
      {
        "text": "segment referencing frequency",
        "correct": false
      }
    ]
  },
  {
    "question": "separate allocation queues for fixed memory blocks of different sizes cause:",
    "answers": [
      {
        "text": "need for compaction",
        "correct": false
      },
      {
        "text": "external fragmentation",
        "correct": true
      },
      {
        "text": "internal fragmentation",
        "correct": true
      }
    ]
  },
  {
    "question": "when the processor is released, the scheduler selects one of the queued processes:",
    "answers": [
      {
        "text": "waiting",
        "correct": false
      },
      {
        "text": "suspended",
        "correct": false
      },
      {
        "text": "running",
        "correct": false
      },
      {
        "text": "ready",
        "correct": true
      }
    ]
  },
  {
    "question": "what mechanism is used to preserve the states of preempted tasks?",
    "answers": [
      {
        "text": "task period",
        "correct": false
      },
      {
        "text": "time slice",
        "correct": false
      },
      {
        "text": "context switch",
        "correct": true
      },
      {
        "text": "batch work",
        "correct": false
      }
    ]
  },
  {
    "question": "static relocation is performed by:",
    "answers": [
      {
        "text": "compiler",
        "correct": true
      },
      {
        "text": "segment descriptors",
        "correct": false
      },
      {
        "text": "paging system",
        "correct": false
      },
      {
        "text": "special registers (datum)",
        "correct": false
      }
    ]
  },
  {
    "question": "the system stack must provide space for:",
    "answers": [
      {
        "text": "cpu registers",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are devices in the system +1",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines and possible software interrupts",
        "correct": false
      },
      {
        "text": "processor registers in as many copies as there are interrupt lines +1",
        "correct": true
      }
    ]
  },
  {
    "question": "internal fragmentation consists in:",
    "answers": [
      {
        "text": "dividing the memory allocated to the program into a data area and a code area",
        "correct": false
      },
      {
        "text": "discontinuous program memory allocation",
        "correct": false
      },
      {
        "text": "free memory blocks between allocated blocks",
        "correct": false
      },
      {
        "text": "the program does not use all the memory allocated to it",
        "correct": true
      }
    ]
  },
  {
    "question": "dynamic relocation is performed by:",
    "answers": [
      {
        "text": "linker",
        "correct": false
      },
      {
        "text": "special registers (datum)",
        "correct": true
      },
      {
        "text": "loader",
        "correct": false
      },
      {
        "text": "compiler",
        "correct": false
      }
    ]
  }
]
